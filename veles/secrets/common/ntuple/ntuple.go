// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package ntuple provides a generic mechanism to detect ordered tuples of
// related secrets (e.g., access key + client ID + client secret) within a raw
// byte buffer. It allows individual elements of the tuple to be matched using
// independent regular expressions and then combines these matches into
// consistent ordered tuples based on occurrence and distance rules.
package ntuple

import (
	"regexp"
	"sort"

	"github.com/google/osv-scalibr/veles"
)

// Match describes a single regex match for one element of a tuple.
// Start and End indicate absolute byte offsets into the input buffer, and
// Value holds the matched bytes.
type Match struct {
	Start int
	End   int
	Value []byte
}

// Tuple represents a completed grouping of individual matches that together
// satisfy tuple constraints. A Tuple includes:
//   - Matches: the ordered list of element matches
//   - Start:   the minimum starting position among all matched elements
//   - End:     the maximum starting position among all elements (not End index)
//   - Dist:    the tuple distance metric = max(StartPositions) - min(EndPositions)
type Tuple struct {
	Matches []Match
	Start   int
	End     int
	Dist    int
}

var _ veles.Detector = &Detector{}

// Detector finds instances of a tuple of keys
// Detector is responsible for finding and resolving N-tuples of secrets.
// Detection happens in two phases:
//
//  1. Full tuple resolution:
//     All Finder patterns must match at least once for a full tuple to be
//     constructed. Candidate tuples are generated by combining one match from
//     each finder. Tuples exceeding MaxDistance are discarded.
//
//  2. Partial fallback (optional):
//     If no full tuples are found AND FromPartial is supplied, each individual
//     match may be returned as a partial secret.
//
// The greedy selection logic prefers tuples with minimal Dist (tightest grouping)
// and avoids reusing overlapping matches across different tuple results.
type Detector struct {
	// MaxDistance defines the maximum allowed distance between tuple components.
	// Distance is computed as: max(startPositions) - min(endPositions).
	// Smaller values prefer tightly grouped matches.
	MaxElementLen uint32

	// MaxDistance defines the maximum allowed distance between tuple components.
	// Distance is computed as: max(startPositions) - min(endPositions).
	// Smaller values prefer tightly grouped matches.
	MaxDistance uint32

	// Finders is a list of regex-based match functions. Each Finder corresponds
	// to one element of the tuple. A valid N-tuple requires one match from each
	// Finder.
	Finders []Finder

	// FromTuple converts a slice of Matches (one from each Finder) into a
	// veles.Secret. If returned bool is false, the tuple is ignored.
	FromTuple func([]Match) (veles.Secret, bool)

	// Returns a veles.Secret from a partial Tuple.
	// FromPartial is used if no full tuples exist. It converts a single Match
	// into a veles.Secret. If nil, partial results are disabled.
	FromPartial func(Match) (veles.Secret, bool)
}

// Finder abstracts a function that returns all regex matches for one tuple
// component in the input buffer.
type Finder func([]byte) []Match

// Detect implements the veles.Detector interface. It returns:
//   - a slice of deduplicated veles.Secret instances
//   - a slice of integer offsets corresponding to each secret’s location
//
// The algorithm:
//
//  1. Apply each Finder to collect matches for all tuple elements.
//  2. Generate all possible N-tuples using one match from each Finder.
//  3. Filter tuples by MaxDistance.
//  4. Sort tuples by Dist (smallest first).
//  5. Greedily select non-overlapping tuples (no shared Start positions).
//  6. If no full tuples are produced and FromPartial is available,
//     return partial matches.
func (d *Detector) Detect(b []byte) ([]veles.Secret, []int) {
	if len(d.Finders) == 0 {
		return nil, nil
	}

	// Step 1: collect matches from all finders
	all := make([][]Match, len(d.Finders))
	for i, f := range d.Finders {
		all[i] = f(b)
	}

	// Step 2: attempt full tuple resolution
	tuples := collectAllTuples(all, int(d.MaxDistance))
	if len(tuples) > 0 {
		// Sort by distance: prefer the most tightly clustered tuple
		sort.Slice(tuples, func(i, j int) bool {
			return tuples[i].Dist < tuples[j].Dist
		})

		used := make(map[int]bool) // positions already used by chosen tuples
		var out []veles.Secret     // final secrets
		var pos []int              // starting offsets

		for _, t := range tuples {
			// Avoid reusing matches from overlapping tuples
			ok := true
			for _, m := range t.Matches {
				if used[m.Start] {
					ok = false
					break
				}
			}
			if !ok {
				continue
			}

			secret, ok := d.FromTuple(t.Matches)
			if !ok {
				continue
			}

			for _, m := range t.Matches {
				used[m.Start] = true
			}

			out = append(out, secret)
			pos = append(pos, t.Start)
		}

		if len(out) > 0 {
			return out, pos
		}
	}

	// Step 3: partial fallback logic
	if d.FromPartial != nil {
		var out []veles.Secret
		var pos []int
		for _, list := range all {
			for _, m := range list {
				secret, ok := d.FromPartial(m)
				if ok {
					out = append(out, secret)
					pos = append(pos, m.Start)
				}
			}
		}
		return out, pos
	}

	return nil, nil
}

// MaxSecretLen implements veles.Detector. It provides an upper bound on the
// total secret length based on element lengths and distance limits. This value
// is not exact—it is a safe maximum used for buffer sizing in other components.
func (d *Detector) MaxSecretLen() uint32 {
	return d.MaxElementLen*2 + d.MaxDistance
}

// FindAllMatches returns a Finder that extracts all non-overlapping regex
// matches using r.FindAllIndex. Each match is converted into a Match with
// absolute byte positions.
func FindAllMatches(r *regexp.Regexp) Finder {
	return func(b []byte) []Match {
		idxs := r.FindAllIndex(b, -1)
		matches := make([]Match, 0, len(idxs))
		for _, idx := range idxs {
			matches = append(matches, Match{
				Start: idx[0],
				End:   idx[1],
				Value: b[idx[0]:idx[1]],
			})
		}
		return matches
	}
}

// collectAllTuples constructs all possible N-tuples using one match from each
// Finder. Filtering by distance happens internally during tuple generation.
func collectAllTuples(all [][]Match, maxDistance int) []Tuple {
	if len(all) == 0 {
		return nil
	}
	return generateTuples(all, 0, nil, maxDistance)
}

// generateTuples recursively creates the Cartesian product of match lists,
// building tuples one Finder at a time. Only tuples meeting the MaxDistance
// threshold are returned.
func generateTuples(all [][]Match, idx int, current []Match, maxDist int) []Tuple {
	if idx == len(all) {
		t := buildTuple(append([]Match(nil), current...))
		if t.Dist <= maxDist {
			return []Tuple{t}
		}
		return nil
	}

	var out []Tuple
	for _, m := range all[idx] {
		next := append(current, m)
		out = append(out, generateTuples(all, idx+1, next, maxDist)...)
	}
	return out
}

// buildTuple sorts matches by starting position and computes:
//   - minStart: earliest start index
//   - maxStart: latest start index
//   - minEnd:   smallest end index
//   - Dist:     maxStart - minEnd
//
// This distance metric ensures that overlapping or extremely distant matches
// are deprioritized or discarded.
func buildTuple(matches []Match) Tuple {
	sort.Slice(matches, func(i, j int) bool {
		return matches[i].Start < matches[j].Start
	})

	minStart := matches[0].Start
	maxStart := matches[0].Start
	minEnd := matches[0].End

	for _, m := range matches[1:] {
		if m.Start < minStart {
			minStart = m.Start
		}
		if m.Start > maxStart {
			maxStart = m.Start
		}
		if m.End < minEnd {
			minEnd = m.End
		}
	}

	dist := maxStart - minEnd
	return Tuple{
		Matches: matches,
		Start:   minStart,
		End:     maxStart,
		Dist:    dist,
	}
}
