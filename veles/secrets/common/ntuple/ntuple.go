// Copyright 2026 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package ntuple provides a generic mechanism to detect ordered tuples of
// related secrets (e.g., access key + client ID + client secret) within a raw
// byte buffer. It allows individual elements of the tuple to be matched using
// independent regular expressions and then combines these matches into
// consistent ordered tuples based on occurrence and distance rules.
package ntuple

import (
	"regexp"
	"sort"

	"github.com/google/osv-scalibr/veles"
)

// Match describes a single regex match for one element of a tuple.
// Start and End indicate absolute byte offsets into the input buffer, and
// Value holds the matched bytes.
// FinderIndex identifies which Finder produced this match.
type Match struct {
	Start       int
	End         int
	Value       []byte
	FinderIndex int
}

// matchKey uniquely identifies a Match instance for deduplication.
// Two matches are considered identical if they originate from the same
// Finder and span the same byte range.
type matchKey struct {
	FinderIndex int
	Start       int
	End         int
}

// Tuple represents a completed grouping of individual matches that together
// satisfy tuple constraints. A Tuple includes:
//   - Matches: the ordered list of element matches
//   - Start:   the minimum starting position among all matched elements
//   - End:     the maximum starting position among all elements (not End index)
//   - Dist:    the tuple distance metric = max(StartPositions) - min(EndPositions)
type Tuple struct {
	Matches []Match
	Start   int
	End     int
	Dist    int
}

var _ veles.Detector = &Detector{}

// Detector finds instances of a tuple of keys
// Detector is responsible for finding and resolving N-tuples of secrets.
// Detection happens in two phases:
//
//  1. Full tuple resolution:
//     All Finder patterns must match at least once for a full tuple to be
//     constructed. Candidate tuples are generated by combining one match from
//     each finder. Tuples exceeding MaxDistance are discarded.
//
//  2. Partial fallback (optional):
//     If no full tuples are found AND FromPartial is supplied, each individual
//     match may be returned as a partial secret.
//
// The greedy selection logic prefers tuples with minimal Dist (tightest grouping)
// and avoids reusing overlapping matches across different tuple results.
type Detector struct {
	// MaxElementLen is used to estimate MaxSecretLen().
	MaxElementLen uint32

	// MaxDistance defines the maximum allowed distance between tuple components.
	// Distance is computed as: max(startPositions) - min(endPositions).
	// Smaller values prefer tightly grouped matches.
	MaxDistance uint32

	// Finders is an ordered list of regex-based match functions.
	// Each Finder corresponds to one element of the tuple, and a valid N-tuple
	// requires at least one match from each Finder.
	//
	// Finders should be ordered from most specific to most generic. This allows
	// the search to exit early if a more specific Finder produces no matches
	// in the file, avoiding unnecessary work by broader matchers.
	Finders []Finder

	// FromTuple converts a slice of Matches (one from each Finder) into a
	// veles.Secret. If returned bool is false, the tuple is ignored.
	FromTuple func([]Match) (veles.Secret, bool)

	// Returns a veles.Secret from a partial Tuple.
	// FromPartial is used if no full tuples exist. It converts a single Match
	// into a veles.Secret. If nil, partial results are disabled.
	FromPartial func(Match) (veles.Secret, bool)
}

// Finder abstracts a function that returns all regex matches for one tuple
// component in the input buffer.
type Finder func([]byte) []Match

// Detect implements the veles.Detector interface. It returns:
//   - a slice of deduplicated veles.Secret instances
//   - a slice of integer offsets corresponding to each secretâ€™s location
//
// The algorithm:
//
//  1. Apply each Finder to collect matches for all tuple elements.
//  2. Generate all possible N-tuples using one match from each Finder.
//  3. Filter tuples by MaxDistance.
//  4. Sort tuples by Dist (smallest first).
//  5. Greedily select non-overlapping tuples (no shared Start positions).
//  6. If no full tuples are produced and FromPartial is available,
//     return partial matches.
func (d *Detector) Detect(b []byte) ([]veles.Secret, []int) {
	if len(d.Finders) == 0 {
		return nil, nil
	}

	all := make([][]Match, len(d.Finders))
	for i, f := range d.Finders {
		matches := f(b)
		if len(matches) == 0 && d.FromPartial == nil {
			return nil, nil
		}
		for j := range matches {
			matches[j].FinderIndex = i
		}
		all[i] = matches
	}

	tuples := collectAllTuples(all, int(d.MaxDistance))
	if len(tuples) == 0 && d.FromPartial == nil {
		return nil, nil
	}

	if len(tuples) > 0 {
		// Sort only for ranking
		sort.Slice(tuples, func(i, j int) bool {
			return tuples[i].Dist < tuples[j].Dist
		})

		// Track already consumed matches so they cannot participate in any future tuples.
		usedMatches := make(map[matchKey]struct{})
		var out []veles.Secret
		var pos []int

		for _, t := range tuples {
			conflict := false
			for _, m := range t.Matches {
				key := matchKey{
					FinderIndex: m.FinderIndex,
					Start:       m.Start,
					End:         m.End,
				}
				if _, used := usedMatches[key]; used {
					conflict = true
					break
				}
			}
			if conflict {
				continue
			}
			secret, ok := d.FromTuple(t.Matches)
			if !ok {
				continue
			}
			// Accept tuple:
			// Mark all of its Matches as consumed so they cannot participate
			// in any future tuples.
			for _, m := range t.Matches {
				key := matchKey{
					FinderIndex: m.FinderIndex,
					Start:       m.Start,
					End:         m.End,
				}
				usedMatches[key] = struct{}{}
			}
			out = append(out, secret)
			pos = append(pos, t.Start)
		}

		if len(out) > 0 {
			return out, pos
		}
	}

	// partial fallback logic
	if d.FromPartial != nil {
		var out []veles.Secret
		var pos []int
		for _, list := range all {
			for _, m := range list {
				secret, ok := d.FromPartial(m)
				if ok {
					out = append(out, secret)
					pos = append(pos, m.Start)
				}
			}
		}
		return out, pos
	}

	return nil, nil
}

// MaxSecretLen returns an upper bound on the total byte-span of a tuple.
// Each tuple consists of exactly one element from each Finder. We assume
// each element may be up to MaxElementLen bytes long, so the total possible
// payload size is MaxElementLen * len(d.Finders).
//
// In addition, tuple construction allows the elements to be separated by
// up to MaxDistance bytes, where MaxDistance is defined as the difference
// between the latest start position and the earliest end position of the
// matched elements. This represents a single contiguous gap spanning from
// the first match to the last match, not one gap per element.
//
// Therefore, the maximum total span of a tuple is:
// MaxElementLen * len(d.Finders) + MaxDistance.
func (d *Detector) MaxSecretLen() uint32 {
	return d.MaxElementLen*uint32(len(d.Finders)) + d.MaxDistance
}

// FindAllMatches returns a Finder that extracts all non-overlapping regex
// matches using r.FindAllIndex. Each match is converted into a Match with
// absolute byte positions.
func FindAllMatches(r *regexp.Regexp) Finder {
	return func(b []byte) []Match {
		idxs := r.FindAllIndex(b, -1)
		matches := make([]Match, 0, len(idxs))
		for _, idx := range idxs {
			matches = append(matches, Match{
				Start: idx[0],
				End:   idx[1],
				Value: b[idx[0]:idx[1]],
			})
		}
		return matches
	}
}

// FindAllMatchesGroup returns a Finder that extracts regex matches similarly to
// FindAllMatches, but with support for context-aware capture groups.
//
// If the provided regexp contains at least one capturing group and that group
// matches, the Match.Value is set to the *first* capturing group, while
// Match.Start and Match.End span the entire match (including surrounding
// context).
//
// If no capturing group exists or the first group did not participate in the
// match, the full match is used both for the span and for Match.Value.
//
// For example, given a regexp like:
//
//	(?:client_secret\s*[:=]\s*)([A-Za-z0-9]{30,})
//
// and input:
//
//	client_secret: ABCDEFGHIJKLMNOPQRSTUVWXYZ1234
//
// Match.Start and Match.End will span the entire string
// "client_secret: ABCDEFGHIJKLMNOPQRSTUVWXYZ1234",
// while Match.Value will contain only:
// "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234".
func FindAllMatchesGroup(r *regexp.Regexp) Finder {
	return func(b []byte) []Match {
		idxs := r.FindAllSubmatchIndex(b, -1)
		matches := make([]Match, 0, len(idxs))

		for _, idx := range idxs {
			// idx layout:
			// [fullStart, fullEnd, g1Start, g1End, g2Start, g2End, ...]
			fullStart, fullEnd := idx[0], idx[1]

			var value []byte

			// If group 1 exists and matched, use it as Value
			if len(idx) >= 4 && idx[2] >= 0 && idx[3] >= 0 {
				value = b[idx[2]:idx[3]]
			} else {
				// fallback: entire match
				value = b[fullStart:fullEnd]
			}

			matches = append(matches, Match{
				Start: fullStart, // full match span
				End:   fullEnd,   // full match span
				Value: value,     // only subgroup value
			})
		}
		return matches
	}
}

// collectAllTuples constructs all possible N-tuples using one match from each
// Finder. Filtering by distance happens internally during tuple generation.
func collectAllTuples(all [][]Match, maxDistance int) []Tuple {
	if len(all) == 0 {
		return nil
	}
	return generateTuples(all, 0, nil, maxDistance)
}

// Standard interval overlap check.
func rangesOverlap(a1, a2, b1, b2 int) bool {
	return a1 < b2 && b1 < a2
}

// generateTuples recursively builds valid combinations only
func generateTuples(all [][]Match, idx int, current []Match, maxDist int) []Tuple {
	// SPECIAL CASE: only one finder. Thus, each match is a tuple
	if len(all) == 1 {
		out := make([]Tuple, 0, len(all[0]))
		for _, m := range all[0] {
			out = append(out, Tuple{
				Matches: []Match{m},
				Start:   m.Start,
				End:     m.End,
				Dist:    0,
			})
		}
		return out
	}

	if idx == len(all) {
		t := buildTuple(append([]Match(nil), current...))
		// Only return the tuple if it's valid (Dist >= 0 and not discarded)
		if t.Dist >= 0 && len(t.Matches) == len(all) { // extra safety
			if t.Dist <= maxDist {
				return []Tuple{t}
			}
		}
		return nil
	}

	var out []Tuple
	for _, m := range all[idx] {
		tmp := make([]Match, len(current)+1)
		copy(tmp, current)
		tmp[len(current)] = m

		sub := generateTuples(all, idx+1, tmp, maxDist)
		out = append(out, sub...)
	}
	return out
}

// buildTuple builds a Tuple from a set of matches
func buildTuple(matches []Match) Tuple {
	n := len(matches)
	if n == 0 {
		return Tuple{}
	}

	// SPECIAL CASE: Only one element. Thus, always valid
	if n == 1 {
		m := matches[0]
		return Tuple{
			Matches: matches,
			Start:   m.Start,
			End:     m.End,
			Dist:    0, // no distance constraint
		}
	}

	// Overlap detection: reject tuple if any two matches overlap
	for i := range matches {
		for j := range matches {
			if j <= i {
				continue
			}
			m1 := matches[i]
			m2 := matches[j]
			if rangesOverlap(m1.Start, m1.End, m2.Start, m2.End) {
				return Tuple{Dist: -1} // mark invalid
			}
		}
	}

	// Sort matches by start position to measure pairwise gaps
	sort.Slice(matches, func(i, j int) bool {
		return matches[i].Start < matches[j].Start
	})

	minStart := matches[0].Start
	maxEnd := matches[0].End
	totalGap := 0

	for i := 1; i < len(matches); i++ {
		prev := matches[i-1]
		curr := matches[i]
		gap := max(0, curr.Start-prev.End) // safety; overlap already rejected earlier
		totalGap += gap
		if curr.End > maxEnd {
			maxEnd = curr.End
		}
	}

	// Sort matches by FinderIndex position to restore finder order
	sort.Slice(matches, func(i, j int) bool {
		return matches[i].FinderIndex < matches[j].FinderIndex
	})

	return Tuple{
		Matches: matches,
		Start:   minStart,
		End:     maxEnd,
		Dist:    totalGap,
	}
}
