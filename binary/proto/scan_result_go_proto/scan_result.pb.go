//
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.21.1
// source: proto/scan_result.proto

package scan_result_go_proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ScanStatus_ScanStatusEnum int32

const (
	ScanStatus_UNSPECIFIED         ScanStatus_ScanStatusEnum = 0
	ScanStatus_SUCCEEDED           ScanStatus_ScanStatusEnum = 1
	ScanStatus_PARTIALLY_SUCCEEDED ScanStatus_ScanStatusEnum = 2
	ScanStatus_FAILED              ScanStatus_ScanStatusEnum = 3
)

// Enum value maps for ScanStatus_ScanStatusEnum.
var (
	ScanStatus_ScanStatusEnum_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "SUCCEEDED",
		2: "PARTIALLY_SUCCEEDED",
		3: "FAILED",
	}
	ScanStatus_ScanStatusEnum_value = map[string]int32{
		"UNSPECIFIED":         0,
		"SUCCEEDED":           1,
		"PARTIALLY_SUCCEEDED": 2,
		"FAILED":              3,
	}
)

func (x ScanStatus_ScanStatusEnum) Enum() *ScanStatus_ScanStatusEnum {
	p := new(ScanStatus_ScanStatusEnum)
	*p = x
	return p
}

func (x ScanStatus_ScanStatusEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ScanStatus_ScanStatusEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_scan_result_proto_enumTypes[0].Descriptor()
}

func (ScanStatus_ScanStatusEnum) Type() protoreflect.EnumType {
	return &file_proto_scan_result_proto_enumTypes[0]
}

func (x ScanStatus_ScanStatusEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ScanStatus_ScanStatusEnum.Descriptor instead.
func (ScanStatus_ScanStatusEnum) EnumDescriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{2, 0}
}

type Package_AnnotationEnum int32

const (
	Package_UNSPECIFIED       Package_AnnotationEnum = 0
	Package_TRANSITIONAL      Package_AnnotationEnum = 1
	Package_INSIDE_OS_PACKAGE Package_AnnotationEnum = 2
	Package_INSIDE_CACHE_DIR  Package_AnnotationEnum = 3
)

// Enum value maps for Package_AnnotationEnum.
var (
	Package_AnnotationEnum_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "TRANSITIONAL",
		2: "INSIDE_OS_PACKAGE",
		3: "INSIDE_CACHE_DIR",
	}
	Package_AnnotationEnum_value = map[string]int32{
		"UNSPECIFIED":       0,
		"TRANSITIONAL":      1,
		"INSIDE_OS_PACKAGE": 2,
		"INSIDE_CACHE_DIR":  3,
	}
)

func (x Package_AnnotationEnum) Enum() *Package_AnnotationEnum {
	p := new(Package_AnnotationEnum)
	*p = x
	return p
}

func (x Package_AnnotationEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Package_AnnotationEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_scan_result_proto_enumTypes[1].Descriptor()
}

func (Package_AnnotationEnum) Type() protoreflect.EnumType {
	return &file_proto_scan_result_proto_enumTypes[1]
}

func (x Package_AnnotationEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Package_AnnotationEnum.Descriptor instead.
func (Package_AnnotationEnum) EnumDescriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{4, 0}
}

type Advisory_TypeEnum int32

const (
	Advisory_UNKNOWN       Advisory_TypeEnum = 0
	Advisory_VULNERABILITY Advisory_TypeEnum = 1
	Advisory_CIS_FINDING   Advisory_TypeEnum = 2
)

// Enum value maps for Advisory_TypeEnum.
var (
	Advisory_TypeEnum_name = map[int32]string{
		0: "UNKNOWN",
		1: "VULNERABILITY",
		2: "CIS_FINDING",
	}
	Advisory_TypeEnum_value = map[string]int32{
		"UNKNOWN":       0,
		"VULNERABILITY": 1,
		"CIS_FINDING":   2,
	}
)

func (x Advisory_TypeEnum) Enum() *Advisory_TypeEnum {
	p := new(Advisory_TypeEnum)
	*p = x
	return p
}

func (x Advisory_TypeEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Advisory_TypeEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_scan_result_proto_enumTypes[2].Descriptor()
}

func (Advisory_TypeEnum) Type() protoreflect.EnumType {
	return &file_proto_scan_result_proto_enumTypes[2]
}

func (x Advisory_TypeEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Advisory_TypeEnum.Descriptor instead.
func (Advisory_TypeEnum) EnumDescriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{10, 0}
}

type Severity_SeverityEnum int32

const (
	Severity_UNSPECIFIED Severity_SeverityEnum = 0
	Severity_MINIMAL     Severity_SeverityEnum = 1
	Severity_LOW         Severity_SeverityEnum = 2
	Severity_MEDIUM      Severity_SeverityEnum = 3
	Severity_HIGH        Severity_SeverityEnum = 4
	Severity_CRITICAL    Severity_SeverityEnum = 5
)

// Enum value maps for Severity_SeverityEnum.
var (
	Severity_SeverityEnum_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "MINIMAL",
		2: "LOW",
		3: "MEDIUM",
		4: "HIGH",
		5: "CRITICAL",
	}
	Severity_SeverityEnum_value = map[string]int32{
		"UNSPECIFIED": 0,
		"MINIMAL":     1,
		"LOW":         2,
		"MEDIUM":      3,
		"HIGH":        4,
		"CRITICAL":    5,
	}
)

func (x Severity_SeverityEnum) Enum() *Severity_SeverityEnum {
	p := new(Severity_SeverityEnum)
	*p = x
	return p
}

func (x Severity_SeverityEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Severity_SeverityEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_scan_result_proto_enumTypes[3].Descriptor()
}

func (Severity_SeverityEnum) Type() protoreflect.EnumType {
	return &file_proto_scan_result_proto_enumTypes[3]
}

func (x Severity_SeverityEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Severity_SeverityEnum.Descriptor instead.
func (Severity_SeverityEnum) EnumDescriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{12, 0}
}

// The results of a scan incl. scan status and artifacts found.
type ScanResult struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	Version   string                 `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	StartTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// Status of the overall scan.
	Status *ScanStatus `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
	// Status and versions of the plugins that ran.
	PluginStatus []*PluginStatus `protobuf:"bytes,5,rep,name=plugin_status,json=pluginStatus,proto3" json:"plugin_status,omitempty"`
	// TODO(b/400910349): Remove once integrators stop using these fields.
	//
	// Deprecated: Marked as deprecated in proto/scan_result.proto.
	InventoriesDeprecated []*Package `protobuf:"bytes,6,rep,name=inventories_deprecated,json=inventoriesDeprecated,proto3" json:"inventories_deprecated,omitempty"`
	// Deprecated: Marked as deprecated in proto/scan_result.proto.
	FindingsDeprecated []*Finding `protobuf:"bytes,7,rep,name=findings_deprecated,json=findingsDeprecated,proto3" json:"findings_deprecated,omitempty"`
	Inventory          *Inventory `protobuf:"bytes,8,opt,name=inventory,proto3" json:"inventory,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *ScanResult) Reset() {
	*x = ScanResult{}
	mi := &file_proto_scan_result_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScanResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScanResult) ProtoMessage() {}

func (x *ScanResult) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScanResult.ProtoReflect.Descriptor instead.
func (*ScanResult) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{0}
}

func (x *ScanResult) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *ScanResult) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *ScanResult) GetEndTime() *timestamppb.Timestamp {
	if x != nil {
		return x.EndTime
	}
	return nil
}

func (x *ScanResult) GetStatus() *ScanStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *ScanResult) GetPluginStatus() []*PluginStatus {
	if x != nil {
		return x.PluginStatus
	}
	return nil
}

// Deprecated: Marked as deprecated in proto/scan_result.proto.
func (x *ScanResult) GetInventoriesDeprecated() []*Package {
	if x != nil {
		return x.InventoriesDeprecated
	}
	return nil
}

// Deprecated: Marked as deprecated in proto/scan_result.proto.
func (x *ScanResult) GetFindingsDeprecated() []*Finding {
	if x != nil {
		return x.FindingsDeprecated
	}
	return nil
}

func (x *ScanResult) GetInventory() *Inventory {
	if x != nil {
		return x.Inventory
	}
	return nil
}

// The artifacts (e.g. software inventory, security findings) that a scan found.
type Inventory struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Packages      []*Package             `protobuf:"bytes,1,rep,name=packages,proto3" json:"packages,omitempty"`
	Findings      []*Finding             `protobuf:"bytes,2,rep,name=findings,proto3" json:"findings,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Inventory) Reset() {
	*x = Inventory{}
	mi := &file_proto_scan_result_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Inventory) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Inventory) ProtoMessage() {}

func (x *Inventory) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Inventory.ProtoReflect.Descriptor instead.
func (*Inventory) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{1}
}

func (x *Inventory) GetPackages() []*Package {
	if x != nil {
		return x.Packages
	}
	return nil
}

func (x *Inventory) GetFindings() []*Finding {
	if x != nil {
		return x.Findings
	}
	return nil
}

type ScanStatus struct {
	state         protoimpl.MessageState    `protogen:"open.v1"`
	Status        ScanStatus_ScanStatusEnum `protobuf:"varint,1,opt,name=status,proto3,enum=scalibr.ScanStatus_ScanStatusEnum" json:"status,omitempty"`
	FailureReason string                    `protobuf:"bytes,2,opt,name=failure_reason,json=failureReason,proto3" json:"failure_reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScanStatus) Reset() {
	*x = ScanStatus{}
	mi := &file_proto_scan_result_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScanStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScanStatus) ProtoMessage() {}

func (x *ScanStatus) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScanStatus.ProtoReflect.Descriptor instead.
func (*ScanStatus) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{2}
}

func (x *ScanStatus) GetStatus() ScanStatus_ScanStatusEnum {
	if x != nil {
		return x.Status
	}
	return ScanStatus_UNSPECIFIED
}

func (x *ScanStatus) GetFailureReason() string {
	if x != nil {
		return x.FailureReason
	}
	return ""
}

type PluginStatus struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Version       int32                  `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	Status        *ScanStatus            `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PluginStatus) Reset() {
	*x = PluginStatus{}
	mi := &file_proto_scan_result_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PluginStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PluginStatus) ProtoMessage() {}

func (x *PluginStatus) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PluginStatus.ProtoReflect.Descriptor instead.
func (*PluginStatus) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{3}
}

func (x *PluginStatus) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *PluginStatus) GetVersion() int32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *PluginStatus) GetStatus() *ScanStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// A software package or library found by an extractor.
// PURL or CPE needs to be set, maybe both.
type Package struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Human-readable name of the software, to be used for things like logging.
	// For vuln matching, use the name from metadata.
	Name string `protobuf:"bytes,11,opt,name=name,proto3" json:"name,omitempty"`
	// Version of the package.
	Version string `protobuf:"bytes,12,opt,name=version,proto3" json:"version,omitempty"`
	// Source code level package identifiers.
	SourceCode *SourceCodeIdentifier `protobuf:"bytes,26,opt,name=source_code,json=sourceCode,proto3" json:"source_code,omitempty"`
	// Package URL of the software.
	Purl *Purl `protobuf:"bytes,1,opt,name=purl,proto3" json:"purl,omitempty"`
	// Ecosystem - For software packages this corresponds to an OSV ecosystem
	// value, e.g. PyPI.
	Ecosystem string `protobuf:"bytes,27,opt,name=ecosystem,proto3" json:"ecosystem,omitempty"`
	// Paths or source of files related to the package.
	Locations []string `protobuf:"bytes,2,rep,name=locations,proto3" json:"locations,omitempty"`
	// The name of the Extractor that found this software. Set by the
	// core library.
	Extractor string `protobuf:"bytes,10,opt,name=extractor,proto3" json:"extractor,omitempty"`
	// The additional data found in the package.
	//
	// Types that are valid to be assigned to Metadata:
	//
	//	*Package_PythonMetadata
	//	*Package_JavascriptMetadata
	//	*Package_ApkMetadata
	//	*Package_DpkgMetadata
	//	*Package_RpmMetadata
	//	*Package_CosMetadata
	//	*Package_DepsjsonMetadata
	//	*Package_SpdxMetadata
	//	*Package_JavaArchiveMetadata
	//	*Package_JavaLockfileMetadata
	//	*Package_PacmanMetadata
	//	*Package_NixMetadata
	//	*Package_KernelModuleMetadata
	//	*Package_VmlinuzMetadata
	//	*Package_PortageMetadata
	//	*Package_OsvMetadata
	//	*Package_PythonRequirementsMetadata
	//	*Package_PythonSetupMetadata
	//	*Package_ContainerdContainerMetadata
	//	*Package_SnapMetadata
	//	*Package_FlatpakMetadata
	//	*Package_MacAppsMetadata
	//	*Package_ContainerdRuntimeContainerMetadata
	//	*Package_CdxMetadata
	//	*Package_WindowsOsVersionMetadata
	//	*Package_HomebrewMetadata
	//	*Package_ChromeExtensionsMetadata
	//	*Package_VscodeExtensionsMetadata
	//	*Package_PodmanMetadata
	//	*Package_DockerContainersMetadata
	Metadata    isPackage_Metadata       `protobuf_oneof:"metadata"`
	Annotations []Package_AnnotationEnum `protobuf:"varint,28,rep,packed,name=annotations,proto3,enum=scalibr.Package_AnnotationEnum" json:"annotations,omitempty"`
	// Details about the layer a package was found in. This should be set only for
	// container image scanning.
	LayerDetails  *LayerDetails `protobuf:"bytes,35,opt,name=layer_details,json=layerDetails,proto3" json:"layer_details,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Package) Reset() {
	*x = Package{}
	mi := &file_proto_scan_result_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Package) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Package) ProtoMessage() {}

func (x *Package) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Package.ProtoReflect.Descriptor instead.
func (*Package) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{4}
}

func (x *Package) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Package) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *Package) GetSourceCode() *SourceCodeIdentifier {
	if x != nil {
		return x.SourceCode
	}
	return nil
}

func (x *Package) GetPurl() *Purl {
	if x != nil {
		return x.Purl
	}
	return nil
}

func (x *Package) GetEcosystem() string {
	if x != nil {
		return x.Ecosystem
	}
	return ""
}

func (x *Package) GetLocations() []string {
	if x != nil {
		return x.Locations
	}
	return nil
}

func (x *Package) GetExtractor() string {
	if x != nil {
		return x.Extractor
	}
	return ""
}

func (x *Package) GetMetadata() isPackage_Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *Package) GetPythonMetadata() *PythonPackageMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_PythonMetadata); ok {
			return x.PythonMetadata
		}
	}
	return nil
}

func (x *Package) GetJavascriptMetadata() *JavascriptPackageJSONMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_JavascriptMetadata); ok {
			return x.JavascriptMetadata
		}
	}
	return nil
}

func (x *Package) GetApkMetadata() *APKPackageMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_ApkMetadata); ok {
			return x.ApkMetadata
		}
	}
	return nil
}

func (x *Package) GetDpkgMetadata() *DPKGPackageMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_DpkgMetadata); ok {
			return x.DpkgMetadata
		}
	}
	return nil
}

func (x *Package) GetRpmMetadata() *RPMPackageMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_RpmMetadata); ok {
			return x.RpmMetadata
		}
	}
	return nil
}

func (x *Package) GetCosMetadata() *COSPackageMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_CosMetadata); ok {
			return x.CosMetadata
		}
	}
	return nil
}

func (x *Package) GetDepsjsonMetadata() *DEPSJSONMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_DepsjsonMetadata); ok {
			return x.DepsjsonMetadata
		}
	}
	return nil
}

func (x *Package) GetSpdxMetadata() *SPDXPackageMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_SpdxMetadata); ok {
			return x.SpdxMetadata
		}
	}
	return nil
}

func (x *Package) GetJavaArchiveMetadata() *JavaArchiveMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_JavaArchiveMetadata); ok {
			return x.JavaArchiveMetadata
		}
	}
	return nil
}

func (x *Package) GetJavaLockfileMetadata() *JavaLockfileMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_JavaLockfileMetadata); ok {
			return x.JavaLockfileMetadata
		}
	}
	return nil
}

func (x *Package) GetPacmanMetadata() *PACMANPackageMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_PacmanMetadata); ok {
			return x.PacmanMetadata
		}
	}
	return nil
}

func (x *Package) GetNixMetadata() *NixPackageMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_NixMetadata); ok {
			return x.NixMetadata
		}
	}
	return nil
}

func (x *Package) GetKernelModuleMetadata() *KernelModuleMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_KernelModuleMetadata); ok {
			return x.KernelModuleMetadata
		}
	}
	return nil
}

func (x *Package) GetVmlinuzMetadata() *VmlinuzMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_VmlinuzMetadata); ok {
			return x.VmlinuzMetadata
		}
	}
	return nil
}

func (x *Package) GetPortageMetadata() *PortagePackageMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_PortageMetadata); ok {
			return x.PortageMetadata
		}
	}
	return nil
}

func (x *Package) GetOsvMetadata() *OSVPackageMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_OsvMetadata); ok {
			return x.OsvMetadata
		}
	}
	return nil
}

func (x *Package) GetPythonRequirementsMetadata() *PythonRequirementsMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_PythonRequirementsMetadata); ok {
			return x.PythonRequirementsMetadata
		}
	}
	return nil
}

func (x *Package) GetPythonSetupMetadata() *PythonSetupMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_PythonSetupMetadata); ok {
			return x.PythonSetupMetadata
		}
	}
	return nil
}

func (x *Package) GetContainerdContainerMetadata() *ContainerdContainerMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_ContainerdContainerMetadata); ok {
			return x.ContainerdContainerMetadata
		}
	}
	return nil
}

func (x *Package) GetSnapMetadata() *SNAPPackageMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_SnapMetadata); ok {
			return x.SnapMetadata
		}
	}
	return nil
}

func (x *Package) GetFlatpakMetadata() *FlatpakPackageMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_FlatpakMetadata); ok {
			return x.FlatpakMetadata
		}
	}
	return nil
}

func (x *Package) GetMacAppsMetadata() *MacAppsMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_MacAppsMetadata); ok {
			return x.MacAppsMetadata
		}
	}
	return nil
}

func (x *Package) GetContainerdRuntimeContainerMetadata() *ContainerdRuntimeContainerMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_ContainerdRuntimeContainerMetadata); ok {
			return x.ContainerdRuntimeContainerMetadata
		}
	}
	return nil
}

func (x *Package) GetCdxMetadata() *CDXPackageMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_CdxMetadata); ok {
			return x.CdxMetadata
		}
	}
	return nil
}

func (x *Package) GetWindowsOsVersionMetadata() *WindowsOSVersion {
	if x != nil {
		if x, ok := x.Metadata.(*Package_WindowsOsVersionMetadata); ok {
			return x.WindowsOsVersionMetadata
		}
	}
	return nil
}

func (x *Package) GetHomebrewMetadata() *HomebrewPackageMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_HomebrewMetadata); ok {
			return x.HomebrewMetadata
		}
	}
	return nil
}

func (x *Package) GetChromeExtensionsMetadata() *ChromeExtensionsMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_ChromeExtensionsMetadata); ok {
			return x.ChromeExtensionsMetadata
		}
	}
	return nil
}

func (x *Package) GetVscodeExtensionsMetadata() *VSCodeExtensionsMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_VscodeExtensionsMetadata); ok {
			return x.VscodeExtensionsMetadata
		}
	}
	return nil
}

func (x *Package) GetPodmanMetadata() *PodmanMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_PodmanMetadata); ok {
			return x.PodmanMetadata
		}
	}
	return nil
}

func (x *Package) GetDockerContainersMetadata() *DockerContainersMetadata {
	if x != nil {
		if x, ok := x.Metadata.(*Package_DockerContainersMetadata); ok {
			return x.DockerContainersMetadata
		}
	}
	return nil
}

func (x *Package) GetAnnotations() []Package_AnnotationEnum {
	if x != nil {
		return x.Annotations
	}
	return nil
}

func (x *Package) GetLayerDetails() *LayerDetails {
	if x != nil {
		return x.LayerDetails
	}
	return nil
}

type isPackage_Metadata interface {
	isPackage_Metadata()
}

type Package_PythonMetadata struct {
	PythonMetadata *PythonPackageMetadata `protobuf:"bytes,5,opt,name=python_metadata,json=pythonMetadata,proto3,oneof"`
}

type Package_JavascriptMetadata struct {
	JavascriptMetadata *JavascriptPackageJSONMetadata `protobuf:"bytes,6,opt,name=javascript_metadata,json=javascriptMetadata,proto3,oneof"`
}

type Package_ApkMetadata struct {
	ApkMetadata *APKPackageMetadata `protobuf:"bytes,7,opt,name=apk_metadata,json=apkMetadata,proto3,oneof"`
}

type Package_DpkgMetadata struct {
	DpkgMetadata *DPKGPackageMetadata `protobuf:"bytes,8,opt,name=dpkg_metadata,json=dpkgMetadata,proto3,oneof"`
}

type Package_RpmMetadata struct {
	RpmMetadata *RPMPackageMetadata `protobuf:"bytes,9,opt,name=rpm_metadata,json=rpmMetadata,proto3,oneof"`
}

type Package_CosMetadata struct {
	CosMetadata *COSPackageMetadata `protobuf:"bytes,13,opt,name=cos_metadata,json=cosMetadata,proto3,oneof"`
}

type Package_DepsjsonMetadata struct {
	DepsjsonMetadata *DEPSJSONMetadata `protobuf:"bytes,40,opt,name=depsjson_metadata,json=depsjsonMetadata,proto3,oneof"`
}

type Package_SpdxMetadata struct {
	SpdxMetadata *SPDXPackageMetadata `protobuf:"bytes,14,opt,name=spdx_metadata,json=spdxMetadata,proto3,oneof"`
}

type Package_JavaArchiveMetadata struct {
	JavaArchiveMetadata *JavaArchiveMetadata `protobuf:"bytes,15,opt,name=java_archive_metadata,json=javaArchiveMetadata,proto3,oneof"`
}

type Package_JavaLockfileMetadata struct {
	JavaLockfileMetadata *JavaLockfileMetadata `protobuf:"bytes,31,opt,name=java_lockfile_metadata,json=javaLockfileMetadata,proto3,oneof"`
}

type Package_PacmanMetadata struct {
	PacmanMetadata *PACMANPackageMetadata `protobuf:"bytes,36,opt,name=pacman_metadata,json=pacmanMetadata,proto3,oneof"`
}

type Package_NixMetadata struct {
	NixMetadata *NixPackageMetadata `protobuf:"bytes,37,opt,name=nix_metadata,json=nixMetadata,proto3,oneof"`
}

type Package_KernelModuleMetadata struct {
	KernelModuleMetadata *KernelModuleMetadata `protobuf:"bytes,38,opt,name=kernel_module_metadata,json=kernelModuleMetadata,proto3,oneof"`
}

type Package_VmlinuzMetadata struct {
	VmlinuzMetadata *VmlinuzMetadata `protobuf:"bytes,39,opt,name=vmlinuz_metadata,json=vmlinuzMetadata,proto3,oneof"`
}

type Package_PortageMetadata struct {
	PortageMetadata *PortagePackageMetadata `protobuf:"bytes,41,opt,name=portage_metadata,json=portageMetadata,proto3,oneof"`
}

type Package_OsvMetadata struct {
	OsvMetadata *OSVPackageMetadata `protobuf:"bytes,16,opt,name=osv_metadata,json=osvMetadata,proto3,oneof"`
}

type Package_PythonRequirementsMetadata struct {
	PythonRequirementsMetadata *PythonRequirementsMetadata `protobuf:"bytes,21,opt,name=python_requirements_metadata,json=pythonRequirementsMetadata,proto3,oneof"`
}

type Package_PythonSetupMetadata struct {
	PythonSetupMetadata *PythonSetupMetadata `protobuf:"bytes,44,opt,name=python_setup_metadata,json=pythonSetupMetadata,proto3,oneof"`
}

type Package_ContainerdContainerMetadata struct {
	ContainerdContainerMetadata *ContainerdContainerMetadata `protobuf:"bytes,22,opt,name=containerd_container_metadata,json=containerdContainerMetadata,proto3,oneof"`
}

type Package_SnapMetadata struct {
	SnapMetadata *SNAPPackageMetadata `protobuf:"bytes,23,opt,name=snap_metadata,json=snapMetadata,proto3,oneof"`
}

type Package_FlatpakMetadata struct {
	FlatpakMetadata *FlatpakPackageMetadata `protobuf:"bytes,24,opt,name=flatpak_metadata,json=flatpakMetadata,proto3,oneof"`
}

type Package_MacAppsMetadata struct {
	MacAppsMetadata *MacAppsMetadata `protobuf:"bytes,34,opt,name=mac_apps_metadata,json=macAppsMetadata,proto3,oneof"`
}

type Package_ContainerdRuntimeContainerMetadata struct {
	ContainerdRuntimeContainerMetadata *ContainerdRuntimeContainerMetadata `protobuf:"bytes,25,opt,name=containerd_runtime_container_metadata,json=containerdRuntimeContainerMetadata,proto3,oneof"`
}

type Package_CdxMetadata struct {
	CdxMetadata *CDXPackageMetadata `protobuf:"bytes,30,opt,name=cdx_metadata,json=cdxMetadata,proto3,oneof"`
}

type Package_WindowsOsVersionMetadata struct {
	WindowsOsVersionMetadata *WindowsOSVersion `protobuf:"bytes,33,opt,name=windows_os_version_metadata,json=windowsOsVersionMetadata,proto3,oneof"`
}

type Package_HomebrewMetadata struct {
	HomebrewMetadata *HomebrewPackageMetadata `protobuf:"bytes,42,opt,name=homebrew_metadata,json=homebrewMetadata,proto3,oneof"`
}

type Package_ChromeExtensionsMetadata struct {
	ChromeExtensionsMetadata *ChromeExtensionsMetadata `protobuf:"bytes,47,opt,name=chrome_extensions_metadata,json=chromeExtensionsMetadata,proto3,oneof"`
}

type Package_VscodeExtensionsMetadata struct {
	VscodeExtensionsMetadata *VSCodeExtensionsMetadata `protobuf:"bytes,46,opt,name=vscode_extensions_metadata,json=vscodeExtensionsMetadata,proto3,oneof"`
}

type Package_PodmanMetadata struct {
	PodmanMetadata *PodmanMetadata `protobuf:"bytes,50,opt,name=podman_metadata,json=podmanMetadata,proto3,oneof"`
}

type Package_DockerContainersMetadata struct {
	DockerContainersMetadata *DockerContainersMetadata `protobuf:"bytes,48,opt,name=docker_containers_metadata,json=dockerContainersMetadata,proto3,oneof"`
}

func (*Package_PythonMetadata) isPackage_Metadata() {}

func (*Package_JavascriptMetadata) isPackage_Metadata() {}

func (*Package_ApkMetadata) isPackage_Metadata() {}

func (*Package_DpkgMetadata) isPackage_Metadata() {}

func (*Package_RpmMetadata) isPackage_Metadata() {}

func (*Package_CosMetadata) isPackage_Metadata() {}

func (*Package_DepsjsonMetadata) isPackage_Metadata() {}

func (*Package_SpdxMetadata) isPackage_Metadata() {}

func (*Package_JavaArchiveMetadata) isPackage_Metadata() {}

func (*Package_JavaLockfileMetadata) isPackage_Metadata() {}

func (*Package_PacmanMetadata) isPackage_Metadata() {}

func (*Package_NixMetadata) isPackage_Metadata() {}

func (*Package_KernelModuleMetadata) isPackage_Metadata() {}

func (*Package_VmlinuzMetadata) isPackage_Metadata() {}

func (*Package_PortageMetadata) isPackage_Metadata() {}

func (*Package_OsvMetadata) isPackage_Metadata() {}

func (*Package_PythonRequirementsMetadata) isPackage_Metadata() {}

func (*Package_PythonSetupMetadata) isPackage_Metadata() {}

func (*Package_ContainerdContainerMetadata) isPackage_Metadata() {}

func (*Package_SnapMetadata) isPackage_Metadata() {}

func (*Package_FlatpakMetadata) isPackage_Metadata() {}

func (*Package_MacAppsMetadata) isPackage_Metadata() {}

func (*Package_ContainerdRuntimeContainerMetadata) isPackage_Metadata() {}

func (*Package_CdxMetadata) isPackage_Metadata() {}

func (*Package_WindowsOsVersionMetadata) isPackage_Metadata() {}

func (*Package_HomebrewMetadata) isPackage_Metadata() {}

func (*Package_ChromeExtensionsMetadata) isPackage_Metadata() {}

func (*Package_VscodeExtensionsMetadata) isPackage_Metadata() {}

func (*Package_PodmanMetadata) isPackage_Metadata() {}

func (*Package_DockerContainersMetadata) isPackage_Metadata() {}

// Additional identifiers for source code software packages (e.g. NPM).
type SourceCodeIdentifier struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Repo          string                 `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Commit        string                 `protobuf:"bytes,2,opt,name=commit,proto3" json:"commit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SourceCodeIdentifier) Reset() {
	*x = SourceCodeIdentifier{}
	mi := &file_proto_scan_result_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SourceCodeIdentifier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SourceCodeIdentifier) ProtoMessage() {}

func (x *SourceCodeIdentifier) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SourceCodeIdentifier.ProtoReflect.Descriptor instead.
func (*SourceCodeIdentifier) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{5}
}

func (x *SourceCodeIdentifier) GetRepo() string {
	if x != nil {
		return x.Repo
	}
	return ""
}

func (x *SourceCodeIdentifier) GetCommit() string {
	if x != nil {
		return x.Commit
	}
	return ""
}

// Details about the layer a package was found in.
type LayerDetails struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The index of the layer in the container image.
	Index int32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// The diff ID (typically a sha256 hash) of the layer in the container image.
	DiffId string `protobuf:"bytes,2,opt,name=diff_id,json=diffId,proto3" json:"diff_id,omitempty"`
	// The layer chain ID (sha256 hash) of the layer in the container image.
	// https://github.com/opencontainers/image-spec/blob/main/config.md#layer-chainid
	ChainId string `protobuf:"bytes,5,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// The layer build command that was used to build the layer. This may not be
	// found in all layers depending on how the container image is built.
	Command string `protobuf:"bytes,3,opt,name=command,proto3" json:"command,omitempty"`
	// Denotes whether the layer is in the base image.
	InBaseImage   bool `protobuf:"varint,4,opt,name=in_base_image,json=inBaseImage,proto3" json:"in_base_image,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LayerDetails) Reset() {
	*x = LayerDetails{}
	mi := &file_proto_scan_result_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LayerDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LayerDetails) ProtoMessage() {}

func (x *LayerDetails) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LayerDetails.ProtoReflect.Descriptor instead.
func (*LayerDetails) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{6}
}

func (x *LayerDetails) GetIndex() int32 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *LayerDetails) GetDiffId() string {
	if x != nil {
		return x.DiffId
	}
	return ""
}

func (x *LayerDetails) GetChainId() string {
	if x != nil {
		return x.ChainId
	}
	return ""
}

func (x *LayerDetails) GetCommand() string {
	if x != nil {
		return x.Command
	}
	return ""
}

func (x *LayerDetails) GetInBaseImage() bool {
	if x != nil {
		return x.InBaseImage
	}
	return false
}

// Package URL, see https://github.com/package-url/purl-spec
type Purl struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// String representation.
	Purl string `protobuf:"bytes,1,opt,name=purl,proto3" json:"purl,omitempty"`
	// Package type, e.g. "maven, npm, pypi".
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// Package name.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Package version.
	Version string `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	// Name prefix such as a Maven groupid, or Docker image owner.
	Namespace string `protobuf:"bytes,5,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Extra qualifying data for a package such as an OS, architecture, etc.
	Qualifiers []*Qualifier `protobuf:"bytes,6,rep,name=qualifiers,proto3" json:"qualifiers,omitempty"`
	// Extra subpath within a package, relative to the package root.
	Subpath       string `protobuf:"bytes,7,opt,name=subpath,proto3" json:"subpath,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Purl) Reset() {
	*x = Purl{}
	mi := &file_proto_scan_result_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Purl) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Purl) ProtoMessage() {}

func (x *Purl) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Purl.ProtoReflect.Descriptor instead.
func (*Purl) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{7}
}

func (x *Purl) GetPurl() string {
	if x != nil {
		return x.Purl
	}
	return ""
}

func (x *Purl) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *Purl) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Purl) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *Purl) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *Purl) GetQualifiers() []*Qualifier {
	if x != nil {
		return x.Qualifiers
	}
	return nil
}

func (x *Purl) GetSubpath() string {
	if x != nil {
		return x.Subpath
	}
	return ""
}

type Qualifier struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         string                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Qualifier) Reset() {
	*x = Qualifier{}
	mi := &file_proto_scan_result_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Qualifier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Qualifier) ProtoMessage() {}

func (x *Qualifier) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Qualifier.ProtoReflect.Descriptor instead.
func (*Qualifier) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{8}
}

func (x *Qualifier) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *Qualifier) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// A security finding found by a detector. It could describe things like a CVE
// or a CIS non-compliance.
type Finding struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Info specific to the finding. Should always be the same for the same type
	// of finding.
	Adv *Advisory `protobuf:"bytes,1,opt,name=adv,proto3" json:"adv,omitempty"`
	// Instance-specific info such as location of the vulnerable files.
	Target *TargetDetails `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	// Additional free-text info.
	Extra string `protobuf:"bytes,3,opt,name=extra,proto3" json:"extra,omitempty"`
	// The name of the Detectors that found this finding. Set by the core library.
	Detectors     []string `protobuf:"bytes,4,rep,name=detectors,proto3" json:"detectors,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Finding) Reset() {
	*x = Finding{}
	mi := &file_proto_scan_result_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Finding) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Finding) ProtoMessage() {}

func (x *Finding) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Finding.ProtoReflect.Descriptor instead.
func (*Finding) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{9}
}

func (x *Finding) GetAdv() *Advisory {
	if x != nil {
		return x.Adv
	}
	return nil
}

func (x *Finding) GetTarget() *TargetDetails {
	if x != nil {
		return x.Target
	}
	return nil
}

func (x *Finding) GetExtra() string {
	if x != nil {
		return x.Extra
	}
	return ""
}

func (x *Finding) GetDetectors() []string {
	if x != nil {
		return x.Detectors
	}
	return nil
}

type Advisory struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A unique ID for the finding.
	Id          *AdvisoryId       `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Type        Advisory_TypeEnum `protobuf:"varint,2,opt,name=type,proto3,enum=scalibr.Advisory_TypeEnum" json:"type,omitempty"`
	Title       string            `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	Description string            `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// Remediation instructions, e.g. "update to latest version".
	Recommendation string    `protobuf:"bytes,5,opt,name=recommendation,proto3" json:"recommendation,omitempty"`
	Sev            *Severity `protobuf:"bytes,6,opt,name=sev,proto3" json:"sev,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Advisory) Reset() {
	*x = Advisory{}
	mi := &file_proto_scan_result_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Advisory) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Advisory) ProtoMessage() {}

func (x *Advisory) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Advisory.ProtoReflect.Descriptor instead.
func (*Advisory) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{10}
}

func (x *Advisory) GetId() *AdvisoryId {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *Advisory) GetType() Advisory_TypeEnum {
	if x != nil {
		return x.Type
	}
	return Advisory_UNKNOWN
}

func (x *Advisory) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *Advisory) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Advisory) GetRecommendation() string {
	if x != nil {
		return x.Recommendation
	}
	return ""
}

func (x *Advisory) GetSev() *Severity {
	if x != nil {
		return x.Sev
	}
	return nil
}

// A unique identifier per advisory.
type AdvisoryId struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Publisher     string                 `protobuf:"bytes,1,opt,name=publisher,proto3" json:"publisher,omitempty"` // e.g. "CVE".
	Reference     string                 `protobuf:"bytes,2,opt,name=reference,proto3" json:"reference,omitempty"` // e.g. "CVE-2023-1234".
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AdvisoryId) Reset() {
	*x = AdvisoryId{}
	mi := &file_proto_scan_result_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AdvisoryId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AdvisoryId) ProtoMessage() {}

func (x *AdvisoryId) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AdvisoryId.ProtoReflect.Descriptor instead.
func (*AdvisoryId) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{11}
}

func (x *AdvisoryId) GetPublisher() string {
	if x != nil {
		return x.Publisher
	}
	return ""
}

func (x *AdvisoryId) GetReference() string {
	if x != nil {
		return x.Reference
	}
	return ""
}

type Severity struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required severity enum. Can be used for e.g. prioritizing filed bugs.
	Severity Severity_SeverityEnum `protobuf:"varint,1,opt,name=severity,proto3,enum=scalibr.Severity_SeverityEnum" json:"severity,omitempty"`
	// Optional CVSS scores, only set for vulns with CVEs.
	CvssV2        *CVSS `protobuf:"bytes,2,opt,name=cvss_v2,json=cvssV2,proto3" json:"cvss_v2,omitempty"`
	CvssV3        *CVSS `protobuf:"bytes,3,opt,name=cvss_v3,json=cvssV3,proto3" json:"cvss_v3,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Severity) Reset() {
	*x = Severity{}
	mi := &file_proto_scan_result_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Severity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Severity) ProtoMessage() {}

func (x *Severity) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Severity.ProtoReflect.Descriptor instead.
func (*Severity) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{12}
}

func (x *Severity) GetSeverity() Severity_SeverityEnum {
	if x != nil {
		return x.Severity
	}
	return Severity_UNSPECIFIED
}

func (x *Severity) GetCvssV2() *CVSS {
	if x != nil {
		return x.CvssV2
	}
	return nil
}

func (x *Severity) GetCvssV3() *CVSS {
	if x != nil {
		return x.CvssV3
	}
	return nil
}

type CVSS struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	BaseScore          float32                `protobuf:"fixed32,1,opt,name=base_score,json=baseScore,proto3" json:"base_score,omitempty"`
	TemporalScore      float32                `protobuf:"fixed32,2,opt,name=temporal_score,json=temporalScore,proto3" json:"temporal_score,omitempty"`
	EnvironmentalScore float32                `protobuf:"fixed32,3,opt,name=environmental_score,json=environmentalScore,proto3" json:"environmental_score,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *CVSS) Reset() {
	*x = CVSS{}
	mi := &file_proto_scan_result_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CVSS) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CVSS) ProtoMessage() {}

func (x *CVSS) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CVSS.ProtoReflect.Descriptor instead.
func (*CVSS) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{13}
}

func (x *CVSS) GetBaseScore() float32 {
	if x != nil {
		return x.BaseScore
	}
	return 0
}

func (x *CVSS) GetTemporalScore() float32 {
	if x != nil {
		return x.TemporalScore
	}
	return 0
}

func (x *CVSS) GetEnvironmentalScore() float32 {
	if x != nil {
		return x.EnvironmentalScore
	}
	return 0
}

type TargetDetails struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The software affected by the finding.
	Package *Package `protobuf:"bytes,1,opt,name=package,proto3" json:"package,omitempty"`
	// Location of vulnerable files not related to the package,
	// e.g. config files with misconfigurations.
	Location      []string `protobuf:"bytes,3,rep,name=location,proto3" json:"location,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TargetDetails) Reset() {
	*x = TargetDetails{}
	mi := &file_proto_scan_result_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TargetDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TargetDetails) ProtoMessage() {}

func (x *TargetDetails) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TargetDetails.ProtoReflect.Descriptor instead.
func (*TargetDetails) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{14}
}

func (x *TargetDetails) GetPackage() *Package {
	if x != nil {
		return x.Package
	}
	return nil
}

func (x *TargetDetails) GetLocation() []string {
	if x != nil {
		return x.Location
	}
	return nil
}

// The additional data found in python packages.
type PythonPackageMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Author        string                 `protobuf:"bytes,1,opt,name=author,proto3" json:"author,omitempty"`
	AuthorEmail   string                 `protobuf:"bytes,2,opt,name=author_email,json=authorEmail,proto3" json:"author_email,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PythonPackageMetadata) Reset() {
	*x = PythonPackageMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PythonPackageMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PythonPackageMetadata) ProtoMessage() {}

func (x *PythonPackageMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PythonPackageMetadata.ProtoReflect.Descriptor instead.
func (*PythonPackageMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{15}
}

func (x *PythonPackageMetadata) GetAuthor() string {
	if x != nil {
		return x.Author
	}
	return ""
}

func (x *PythonPackageMetadata) GetAuthorEmail() string {
	if x != nil {
		return x.AuthorEmail
	}
	return ""
}

// The additional data found in npm packages.
type JavascriptPackageJSONMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Author        string                 `protobuf:"bytes,1,opt,name=author,proto3" json:"author,omitempty"`
	Maintainers   []string               `protobuf:"bytes,2,rep,name=maintainers,proto3" json:"maintainers,omitempty"`
	Contributors  []string               `protobuf:"bytes,3,rep,name=contributors,proto3" json:"contributors,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *JavascriptPackageJSONMetadata) Reset() {
	*x = JavascriptPackageJSONMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JavascriptPackageJSONMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JavascriptPackageJSONMetadata) ProtoMessage() {}

func (x *JavascriptPackageJSONMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JavascriptPackageJSONMetadata.ProtoReflect.Descriptor instead.
func (*JavascriptPackageJSONMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{16}
}

func (x *JavascriptPackageJSONMetadata) GetAuthor() string {
	if x != nil {
		return x.Author
	}
	return ""
}

func (x *JavascriptPackageJSONMetadata) GetMaintainers() []string {
	if x != nil {
		return x.Maintainers
	}
	return nil
}

func (x *JavascriptPackageJSONMetadata) GetContributors() []string {
	if x != nil {
		return x.Contributors
	}
	return nil
}

// The additional data found in APK packages.
type APKPackageMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PackageName   string                 `protobuf:"bytes,1,opt,name=package_name,json=packageName,proto3" json:"package_name,omitempty"`
	OriginName    string                 `protobuf:"bytes,2,opt,name=origin_name,json=originName,proto3" json:"origin_name,omitempty"`
	OsId          string                 `protobuf:"bytes,3,opt,name=os_id,json=osId,proto3" json:"os_id,omitempty"`
	OsVersionId   string                 `protobuf:"bytes,4,opt,name=os_version_id,json=osVersionId,proto3" json:"os_version_id,omitempty"`
	Maintainer    string                 `protobuf:"bytes,5,opt,name=maintainer,proto3" json:"maintainer,omitempty"`
	Architecture  string                 `protobuf:"bytes,6,opt,name=architecture,proto3" json:"architecture,omitempty"`
	License       string                 `protobuf:"bytes,7,opt,name=license,proto3" json:"license,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *APKPackageMetadata) Reset() {
	*x = APKPackageMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *APKPackageMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*APKPackageMetadata) ProtoMessage() {}

func (x *APKPackageMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use APKPackageMetadata.ProtoReflect.Descriptor instead.
func (*APKPackageMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{17}
}

func (x *APKPackageMetadata) GetPackageName() string {
	if x != nil {
		return x.PackageName
	}
	return ""
}

func (x *APKPackageMetadata) GetOriginName() string {
	if x != nil {
		return x.OriginName
	}
	return ""
}

func (x *APKPackageMetadata) GetOsId() string {
	if x != nil {
		return x.OsId
	}
	return ""
}

func (x *APKPackageMetadata) GetOsVersionId() string {
	if x != nil {
		return x.OsVersionId
	}
	return ""
}

func (x *APKPackageMetadata) GetMaintainer() string {
	if x != nil {
		return x.Maintainer
	}
	return ""
}

func (x *APKPackageMetadata) GetArchitecture() string {
	if x != nil {
		return x.Architecture
	}
	return ""
}

func (x *APKPackageMetadata) GetLicense() string {
	if x != nil {
		return x.License
	}
	return ""
}

// The additional data found in DPKG packages.
// Next ID: 11
type DPKGPackageMetadata struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	PackageName       string                 `protobuf:"bytes,1,opt,name=package_name,json=packageName,proto3" json:"package_name,omitempty"`
	SourceName        string                 `protobuf:"bytes,2,opt,name=source_name,json=sourceName,proto3" json:"source_name,omitempty"`
	SourceVersion     string                 `protobuf:"bytes,3,opt,name=source_version,json=sourceVersion,proto3" json:"source_version,omitempty"`
	PackageVersion    string                 `protobuf:"bytes,4,opt,name=package_version,json=packageVersion,proto3" json:"package_version,omitempty"`
	OsId              string                 `protobuf:"bytes,5,opt,name=os_id,json=osId,proto3" json:"os_id,omitempty"`
	OsVersionCodename string                 `protobuf:"bytes,6,opt,name=os_version_codename,json=osVersionCodename,proto3" json:"os_version_codename,omitempty"`
	OsVersionId       string                 `protobuf:"bytes,7,opt,name=os_version_id,json=osVersionId,proto3" json:"os_version_id,omitempty"`
	Maintainer        string                 `protobuf:"bytes,8,opt,name=maintainer,proto3" json:"maintainer,omitempty"`
	Architecture      string                 `protobuf:"bytes,9,opt,name=architecture,proto3" json:"architecture,omitempty"`
	Status            string                 `protobuf:"bytes,10,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *DPKGPackageMetadata) Reset() {
	*x = DPKGPackageMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DPKGPackageMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DPKGPackageMetadata) ProtoMessage() {}

func (x *DPKGPackageMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DPKGPackageMetadata.ProtoReflect.Descriptor instead.
func (*DPKGPackageMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{18}
}

func (x *DPKGPackageMetadata) GetPackageName() string {
	if x != nil {
		return x.PackageName
	}
	return ""
}

func (x *DPKGPackageMetadata) GetSourceName() string {
	if x != nil {
		return x.SourceName
	}
	return ""
}

func (x *DPKGPackageMetadata) GetSourceVersion() string {
	if x != nil {
		return x.SourceVersion
	}
	return ""
}

func (x *DPKGPackageMetadata) GetPackageVersion() string {
	if x != nil {
		return x.PackageVersion
	}
	return ""
}

func (x *DPKGPackageMetadata) GetOsId() string {
	if x != nil {
		return x.OsId
	}
	return ""
}

func (x *DPKGPackageMetadata) GetOsVersionCodename() string {
	if x != nil {
		return x.OsVersionCodename
	}
	return ""
}

func (x *DPKGPackageMetadata) GetOsVersionId() string {
	if x != nil {
		return x.OsVersionId
	}
	return ""
}

func (x *DPKGPackageMetadata) GetMaintainer() string {
	if x != nil {
		return x.Maintainer
	}
	return ""
}

func (x *DPKGPackageMetadata) GetArchitecture() string {
	if x != nil {
		return x.Architecture
	}
	return ""
}

func (x *DPKGPackageMetadata) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

// The additional data found in RPM packages.
type RPMPackageMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PackageName   string                 `protobuf:"bytes,1,opt,name=package_name,json=packageName,proto3" json:"package_name,omitempty"`
	SourceRpm     string                 `protobuf:"bytes,2,opt,name=source_rpm,json=sourceRpm,proto3" json:"source_rpm,omitempty"`
	Epoch         int32                  `protobuf:"varint,3,opt,name=epoch,proto3" json:"epoch,omitempty"`
	OsId          string                 `protobuf:"bytes,4,opt,name=os_id,json=osId,proto3" json:"os_id,omitempty"`
	OsVersionId   string                 `protobuf:"bytes,5,opt,name=os_version_id,json=osVersionId,proto3" json:"os_version_id,omitempty"`
	OsBuildId     string                 `protobuf:"bytes,6,opt,name=os_build_id,json=osBuildId,proto3" json:"os_build_id,omitempty"`
	OsName        string                 `protobuf:"bytes,7,opt,name=os_name,json=osName,proto3" json:"os_name,omitempty"`
	Vendor        string                 `protobuf:"bytes,8,opt,name=vendor,proto3" json:"vendor,omitempty"`
	Architecture  string                 `protobuf:"bytes,9,opt,name=architecture,proto3" json:"architecture,omitempty"`
	License       string                 `protobuf:"bytes,10,opt,name=license,proto3" json:"license,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RPMPackageMetadata) Reset() {
	*x = RPMPackageMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RPMPackageMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RPMPackageMetadata) ProtoMessage() {}

func (x *RPMPackageMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RPMPackageMetadata.ProtoReflect.Descriptor instead.
func (*RPMPackageMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{19}
}

func (x *RPMPackageMetadata) GetPackageName() string {
	if x != nil {
		return x.PackageName
	}
	return ""
}

func (x *RPMPackageMetadata) GetSourceRpm() string {
	if x != nil {
		return x.SourceRpm
	}
	return ""
}

func (x *RPMPackageMetadata) GetEpoch() int32 {
	if x != nil {
		return x.Epoch
	}
	return 0
}

func (x *RPMPackageMetadata) GetOsId() string {
	if x != nil {
		return x.OsId
	}
	return ""
}

func (x *RPMPackageMetadata) GetOsVersionId() string {
	if x != nil {
		return x.OsVersionId
	}
	return ""
}

func (x *RPMPackageMetadata) GetOsBuildId() string {
	if x != nil {
		return x.OsBuildId
	}
	return ""
}

func (x *RPMPackageMetadata) GetOsName() string {
	if x != nil {
		return x.OsName
	}
	return ""
}

func (x *RPMPackageMetadata) GetVendor() string {
	if x != nil {
		return x.Vendor
	}
	return ""
}

func (x *RPMPackageMetadata) GetArchitecture() string {
	if x != nil {
		return x.Architecture
	}
	return ""
}

func (x *RPMPackageMetadata) GetLicense() string {
	if x != nil {
		return x.License
	}
	return ""
}

// The additional data found in COS packages.
type COSPackageMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Version       string                 `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Category      string                 `protobuf:"bytes,3,opt,name=category,proto3" json:"category,omitempty"`
	OsVersion     string                 `protobuf:"bytes,4,opt,name=os_version,json=osVersion,proto3" json:"os_version,omitempty"`
	OsVersionId   string                 `protobuf:"bytes,5,opt,name=os_version_id,json=osVersionId,proto3" json:"os_version_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *COSPackageMetadata) Reset() {
	*x = COSPackageMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *COSPackageMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*COSPackageMetadata) ProtoMessage() {}

func (x *COSPackageMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use COSPackageMetadata.ProtoReflect.Descriptor instead.
func (*COSPackageMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{20}
}

func (x *COSPackageMetadata) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *COSPackageMetadata) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *COSPackageMetadata) GetCategory() string {
	if x != nil {
		return x.Category
	}
	return ""
}

func (x *COSPackageMetadata) GetOsVersion() string {
	if x != nil {
		return x.OsVersion
	}
	return ""
}

func (x *COSPackageMetadata) GetOsVersionId() string {
	if x != nil {
		return x.OsVersionId
	}
	return ""
}

// The additional data found in PACMAN packages.
type PACMANPackageMetadata struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	PackageName         string                 `protobuf:"bytes,1,opt,name=package_name,json=packageName,proto3" json:"package_name,omitempty"`
	PackageVersion      string                 `protobuf:"bytes,2,opt,name=package_version,json=packageVersion,proto3" json:"package_version,omitempty"`
	OsId                string                 `protobuf:"bytes,3,opt,name=os_id,json=osId,proto3" json:"os_id,omitempty"`
	OsVersionId         string                 `protobuf:"bytes,4,opt,name=os_version_id,json=osVersionId,proto3" json:"os_version_id,omitempty"`
	PackageDescription  string                 `protobuf:"bytes,5,opt,name=package_description,json=packageDescription,proto3" json:"package_description,omitempty"`
	PackageDependencies string                 `protobuf:"bytes,6,opt,name=package_dependencies,json=packageDependencies,proto3" json:"package_dependencies,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *PACMANPackageMetadata) Reset() {
	*x = PACMANPackageMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PACMANPackageMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PACMANPackageMetadata) ProtoMessage() {}

func (x *PACMANPackageMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PACMANPackageMetadata.ProtoReflect.Descriptor instead.
func (*PACMANPackageMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{21}
}

func (x *PACMANPackageMetadata) GetPackageName() string {
	if x != nil {
		return x.PackageName
	}
	return ""
}

func (x *PACMANPackageMetadata) GetPackageVersion() string {
	if x != nil {
		return x.PackageVersion
	}
	return ""
}

func (x *PACMANPackageMetadata) GetOsId() string {
	if x != nil {
		return x.OsId
	}
	return ""
}

func (x *PACMANPackageMetadata) GetOsVersionId() string {
	if x != nil {
		return x.OsVersionId
	}
	return ""
}

func (x *PACMANPackageMetadata) GetPackageDescription() string {
	if x != nil {
		return x.PackageDescription
	}
	return ""
}

func (x *PACMANPackageMetadata) GetPackageDependencies() string {
	if x != nil {
		return x.PackageDependencies
	}
	return ""
}

// The additional data found in Nix packages.
type NixPackageMetadata struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	PackageName       string                 `protobuf:"bytes,1,opt,name=package_name,json=packageName,proto3" json:"package_name,omitempty"`
	PackageVersion    string                 `protobuf:"bytes,2,opt,name=package_version,json=packageVersion,proto3" json:"package_version,omitempty"`
	PackageHash       string                 `protobuf:"bytes,3,opt,name=package_hash,json=packageHash,proto3" json:"package_hash,omitempty"`
	PackageOutput     string                 `protobuf:"bytes,4,opt,name=package_output,json=packageOutput,proto3" json:"package_output,omitempty"`
	OsId              string                 `protobuf:"bytes,5,opt,name=os_id,json=osId,proto3" json:"os_id,omitempty"`
	OsVersionCodename string                 `protobuf:"bytes,6,opt,name=os_version_codename,json=osVersionCodename,proto3" json:"os_version_codename,omitempty"`
	OsVersionId       string                 `protobuf:"bytes,7,opt,name=os_version_id,json=osVersionId,proto3" json:"os_version_id,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *NixPackageMetadata) Reset() {
	*x = NixPackageMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NixPackageMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NixPackageMetadata) ProtoMessage() {}

func (x *NixPackageMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NixPackageMetadata.ProtoReflect.Descriptor instead.
func (*NixPackageMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{22}
}

func (x *NixPackageMetadata) GetPackageName() string {
	if x != nil {
		return x.PackageName
	}
	return ""
}

func (x *NixPackageMetadata) GetPackageVersion() string {
	if x != nil {
		return x.PackageVersion
	}
	return ""
}

func (x *NixPackageMetadata) GetPackageHash() string {
	if x != nil {
		return x.PackageHash
	}
	return ""
}

func (x *NixPackageMetadata) GetPackageOutput() string {
	if x != nil {
		return x.PackageOutput
	}
	return ""
}

func (x *NixPackageMetadata) GetOsId() string {
	if x != nil {
		return x.OsId
	}
	return ""
}

func (x *NixPackageMetadata) GetOsVersionCodename() string {
	if x != nil {
		return x.OsVersionCodename
	}
	return ""
}

func (x *NixPackageMetadata) GetOsVersionId() string {
	if x != nil {
		return x.OsVersionId
	}
	return ""
}

// The additional data found in .NET deps json packages.
type DEPSJSONMetadata struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	PackageName    string                 `protobuf:"bytes,1,opt,name=package_name,json=packageName,proto3" json:"package_name,omitempty"`
	PackageVersion string                 `protobuf:"bytes,2,opt,name=package_version,json=packageVersion,proto3" json:"package_version,omitempty"`
	Type           string                 `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *DEPSJSONMetadata) Reset() {
	*x = DEPSJSONMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DEPSJSONMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DEPSJSONMetadata) ProtoMessage() {}

func (x *DEPSJSONMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DEPSJSONMetadata.ProtoReflect.Descriptor instead.
func (*DEPSJSONMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{23}
}

func (x *DEPSJSONMetadata) GetPackageName() string {
	if x != nil {
		return x.PackageName
	}
	return ""
}

func (x *DEPSJSONMetadata) GetPackageVersion() string {
	if x != nil {
		return x.PackageVersion
	}
	return ""
}

func (x *DEPSJSONMetadata) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

// The additional data found in SNAP packages.
type SNAPPackageMetadata struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Name              string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Version           string                 `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Grade             string                 `protobuf:"bytes,3,opt,name=grade,proto3" json:"grade,omitempty"`
	Type              string                 `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	Architectures     []string               `protobuf:"bytes,5,rep,name=architectures,proto3" json:"architectures,omitempty"`
	OsId              string                 `protobuf:"bytes,6,opt,name=os_id,json=osId,proto3" json:"os_id,omitempty"`
	OsVersionCodename string                 `protobuf:"bytes,7,opt,name=os_version_codename,json=osVersionCodename,proto3" json:"os_version_codename,omitempty"`
	OsVersionId       string                 `protobuf:"bytes,8,opt,name=os_version_id,json=osVersionId,proto3" json:"os_version_id,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *SNAPPackageMetadata) Reset() {
	*x = SNAPPackageMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SNAPPackageMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SNAPPackageMetadata) ProtoMessage() {}

func (x *SNAPPackageMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SNAPPackageMetadata.ProtoReflect.Descriptor instead.
func (*SNAPPackageMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{24}
}

func (x *SNAPPackageMetadata) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *SNAPPackageMetadata) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *SNAPPackageMetadata) GetGrade() string {
	if x != nil {
		return x.Grade
	}
	return ""
}

func (x *SNAPPackageMetadata) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *SNAPPackageMetadata) GetArchitectures() []string {
	if x != nil {
		return x.Architectures
	}
	return nil
}

func (x *SNAPPackageMetadata) GetOsId() string {
	if x != nil {
		return x.OsId
	}
	return ""
}

func (x *SNAPPackageMetadata) GetOsVersionCodename() string {
	if x != nil {
		return x.OsVersionCodename
	}
	return ""
}

func (x *SNAPPackageMetadata) GetOsVersionId() string {
	if x != nil {
		return x.OsVersionId
	}
	return ""
}

// The additional data found in portage packages.
type PortagePackageMetadata struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	PackageName    string                 `protobuf:"bytes,1,opt,name=package_name,json=packageName,proto3" json:"package_name,omitempty"`
	PackageVersion string                 `protobuf:"bytes,2,opt,name=package_version,json=packageVersion,proto3" json:"package_version,omitempty"`
	OsId           string                 `protobuf:"bytes,3,opt,name=os_id,json=osId,proto3" json:"os_id,omitempty"`
	OsVersionId    string                 `protobuf:"bytes,4,opt,name=os_version_id,json=osVersionId,proto3" json:"os_version_id,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *PortagePackageMetadata) Reset() {
	*x = PortagePackageMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PortagePackageMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PortagePackageMetadata) ProtoMessage() {}

func (x *PortagePackageMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PortagePackageMetadata.ProtoReflect.Descriptor instead.
func (*PortagePackageMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{25}
}

func (x *PortagePackageMetadata) GetPackageName() string {
	if x != nil {
		return x.PackageName
	}
	return ""
}

func (x *PortagePackageMetadata) GetPackageVersion() string {
	if x != nil {
		return x.PackageVersion
	}
	return ""
}

func (x *PortagePackageMetadata) GetOsId() string {
	if x != nil {
		return x.OsId
	}
	return ""
}

func (x *PortagePackageMetadata) GetOsVersionId() string {
	if x != nil {
		return x.OsVersionId
	}
	return ""
}

// The additional data found in Flatpak packages.
type FlatpakPackageMetadata struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	PackageName    string                 `protobuf:"bytes,1,opt,name=package_name,json=packageName,proto3" json:"package_name,omitempty"`
	PackageId      string                 `protobuf:"bytes,2,opt,name=package_id,json=packageId,proto3" json:"package_id,omitempty"`
	PackageVersion string                 `protobuf:"bytes,3,opt,name=package_version,json=packageVersion,proto3" json:"package_version,omitempty"`
	ReleaseDate    string                 `protobuf:"bytes,4,opt,name=release_date,json=releaseDate,proto3" json:"release_date,omitempty"`
	OsName         string                 `protobuf:"bytes,5,opt,name=os_name,json=osName,proto3" json:"os_name,omitempty"`
	OsId           string                 `protobuf:"bytes,6,opt,name=os_id,json=osId,proto3" json:"os_id,omitempty"`
	OsVersionId    string                 `protobuf:"bytes,7,opt,name=os_version_id,json=osVersionId,proto3" json:"os_version_id,omitempty"`
	OsBuildId      string                 `protobuf:"bytes,8,opt,name=os_build_id,json=osBuildId,proto3" json:"os_build_id,omitempty"`
	Developer      string                 `protobuf:"bytes,9,opt,name=developer,proto3" json:"developer,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *FlatpakPackageMetadata) Reset() {
	*x = FlatpakPackageMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlatpakPackageMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlatpakPackageMetadata) ProtoMessage() {}

func (x *FlatpakPackageMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlatpakPackageMetadata.ProtoReflect.Descriptor instead.
func (*FlatpakPackageMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{26}
}

func (x *FlatpakPackageMetadata) GetPackageName() string {
	if x != nil {
		return x.PackageName
	}
	return ""
}

func (x *FlatpakPackageMetadata) GetPackageId() string {
	if x != nil {
		return x.PackageId
	}
	return ""
}

func (x *FlatpakPackageMetadata) GetPackageVersion() string {
	if x != nil {
		return x.PackageVersion
	}
	return ""
}

func (x *FlatpakPackageMetadata) GetReleaseDate() string {
	if x != nil {
		return x.ReleaseDate
	}
	return ""
}

func (x *FlatpakPackageMetadata) GetOsName() string {
	if x != nil {
		return x.OsName
	}
	return ""
}

func (x *FlatpakPackageMetadata) GetOsId() string {
	if x != nil {
		return x.OsId
	}
	return ""
}

func (x *FlatpakPackageMetadata) GetOsVersionId() string {
	if x != nil {
		return x.OsVersionId
	}
	return ""
}

func (x *FlatpakPackageMetadata) GetOsBuildId() string {
	if x != nil {
		return x.OsBuildId
	}
	return ""
}

func (x *FlatpakPackageMetadata) GetDeveloper() string {
	if x != nil {
		return x.Developer
	}
	return ""
}

// The additional data found in MODULE packages.
type KernelModuleMetadata struct {
	state                          protoimpl.MessageState `protogen:"open.v1"`
	PackageName                    string                 `protobuf:"bytes,1,opt,name=package_name,json=packageName,proto3" json:"package_name,omitempty"`
	PackageVersion                 string                 `protobuf:"bytes,2,opt,name=package_version,json=packageVersion,proto3" json:"package_version,omitempty"`
	PackageVermagic                string                 `protobuf:"bytes,3,opt,name=package_vermagic,json=packageVermagic,proto3" json:"package_vermagic,omitempty"`
	PackageSourceVersionIdentifier string                 `protobuf:"bytes,4,opt,name=package_source_version_identifier,json=packageSourceVersionIdentifier,proto3" json:"package_source_version_identifier,omitempty"`
	OsId                           string                 `protobuf:"bytes,5,opt,name=os_id,json=osId,proto3" json:"os_id,omitempty"`
	OsVersionCodename              string                 `protobuf:"bytes,6,opt,name=os_version_codename,json=osVersionCodename,proto3" json:"os_version_codename,omitempty"`
	OsVersionId                    string                 `protobuf:"bytes,7,opt,name=os_version_id,json=osVersionId,proto3" json:"os_version_id,omitempty"`
	PackageAuthor                  string                 `protobuf:"bytes,8,opt,name=package_author,json=packageAuthor,proto3" json:"package_author,omitempty"`
	unknownFields                  protoimpl.UnknownFields
	sizeCache                      protoimpl.SizeCache
}

func (x *KernelModuleMetadata) Reset() {
	*x = KernelModuleMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KernelModuleMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KernelModuleMetadata) ProtoMessage() {}

func (x *KernelModuleMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KernelModuleMetadata.ProtoReflect.Descriptor instead.
func (*KernelModuleMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{27}
}

func (x *KernelModuleMetadata) GetPackageName() string {
	if x != nil {
		return x.PackageName
	}
	return ""
}

func (x *KernelModuleMetadata) GetPackageVersion() string {
	if x != nil {
		return x.PackageVersion
	}
	return ""
}

func (x *KernelModuleMetadata) GetPackageVermagic() string {
	if x != nil {
		return x.PackageVermagic
	}
	return ""
}

func (x *KernelModuleMetadata) GetPackageSourceVersionIdentifier() string {
	if x != nil {
		return x.PackageSourceVersionIdentifier
	}
	return ""
}

func (x *KernelModuleMetadata) GetOsId() string {
	if x != nil {
		return x.OsId
	}
	return ""
}

func (x *KernelModuleMetadata) GetOsVersionCodename() string {
	if x != nil {
		return x.OsVersionCodename
	}
	return ""
}

func (x *KernelModuleMetadata) GetOsVersionId() string {
	if x != nil {
		return x.OsVersionId
	}
	return ""
}

func (x *KernelModuleMetadata) GetPackageAuthor() string {
	if x != nil {
		return x.PackageAuthor
	}
	return ""
}

// The additional data found in Vmlinuz packages.
type VmlinuzMetadata struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Name              string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Version           string                 `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Architecture      string                 `protobuf:"bytes,3,opt,name=architecture,proto3" json:"architecture,omitempty"`
	ExtendedVersion   string                 `protobuf:"bytes,4,opt,name=extended_version,json=extendedVersion,proto3" json:"extended_version,omitempty"`
	Format            string                 `protobuf:"bytes,5,opt,name=format,proto3" json:"format,omitempty"`
	SwapDevice        int32                  `protobuf:"varint,6,opt,name=swap_device,json=swapDevice,proto3" json:"swap_device,omitempty"`
	RootDevice        int32                  `protobuf:"varint,7,opt,name=root_device,json=rootDevice,proto3" json:"root_device,omitempty"`
	VideoMode         string                 `protobuf:"bytes,8,opt,name=video_mode,json=videoMode,proto3" json:"video_mode,omitempty"`
	OsId              string                 `protobuf:"bytes,9,opt,name=os_id,json=osId,proto3" json:"os_id,omitempty"`
	OsVersionCodename string                 `protobuf:"bytes,10,opt,name=os_version_codename,json=osVersionCodename,proto3" json:"os_version_codename,omitempty"`
	OsVersionId       string                 `protobuf:"bytes,11,opt,name=os_version_id,json=osVersionId,proto3" json:"os_version_id,omitempty"`
	RwRootFs          bool                   `protobuf:"varint,12,opt,name=rw_root_fs,json=rwRootFs,proto3" json:"rw_root_fs,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *VmlinuzMetadata) Reset() {
	*x = VmlinuzMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VmlinuzMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VmlinuzMetadata) ProtoMessage() {}

func (x *VmlinuzMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VmlinuzMetadata.ProtoReflect.Descriptor instead.
func (*VmlinuzMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{28}
}

func (x *VmlinuzMetadata) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *VmlinuzMetadata) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *VmlinuzMetadata) GetArchitecture() string {
	if x != nil {
		return x.Architecture
	}
	return ""
}

func (x *VmlinuzMetadata) GetExtendedVersion() string {
	if x != nil {
		return x.ExtendedVersion
	}
	return ""
}

func (x *VmlinuzMetadata) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

func (x *VmlinuzMetadata) GetSwapDevice() int32 {
	if x != nil {
		return x.SwapDevice
	}
	return 0
}

func (x *VmlinuzMetadata) GetRootDevice() int32 {
	if x != nil {
		return x.RootDevice
	}
	return 0
}

func (x *VmlinuzMetadata) GetVideoMode() string {
	if x != nil {
		return x.VideoMode
	}
	return ""
}

func (x *VmlinuzMetadata) GetOsId() string {
	if x != nil {
		return x.OsId
	}
	return ""
}

func (x *VmlinuzMetadata) GetOsVersionCodename() string {
	if x != nil {
		return x.OsVersionCodename
	}
	return ""
}

func (x *VmlinuzMetadata) GetOsVersionId() string {
	if x != nil {
		return x.OsVersionId
	}
	return ""
}

func (x *VmlinuzMetadata) GetRwRootFs() bool {
	if x != nil {
		return x.RwRootFs
	}
	return false
}

// The additional data found in Mac Applications.
type MacAppsMetadata struct {
	state                    protoimpl.MessageState `protogen:"open.v1"`
	BundleDisplayName        string                 `protobuf:"bytes,1,opt,name=bundle_display_name,json=bundleDisplayName,proto3" json:"bundle_display_name,omitempty"`
	BundleIdentifier         string                 `protobuf:"bytes,2,opt,name=bundle_identifier,json=bundleIdentifier,proto3" json:"bundle_identifier,omitempty"`
	BundleShortVersionString string                 `protobuf:"bytes,3,opt,name=bundle_short_version_string,json=bundleShortVersionString,proto3" json:"bundle_short_version_string,omitempty"`
	BundleExecutable         string                 `protobuf:"bytes,4,opt,name=bundle_executable,json=bundleExecutable,proto3" json:"bundle_executable,omitempty"`
	BundleName               string                 `protobuf:"bytes,5,opt,name=bundle_name,json=bundleName,proto3" json:"bundle_name,omitempty"`
	BundlePackageType        string                 `protobuf:"bytes,6,opt,name=bundle_package_type,json=bundlePackageType,proto3" json:"bundle_package_type,omitempty"`
	BundleSignature          string                 `protobuf:"bytes,7,opt,name=bundle_signature,json=bundleSignature,proto3" json:"bundle_signature,omitempty"`
	BundleVersion            string                 `protobuf:"bytes,8,opt,name=bundle_version,json=bundleVersion,proto3" json:"bundle_version,omitempty"`
	ProductId                string                 `protobuf:"bytes,9,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	UpdateUrl                string                 `protobuf:"bytes,10,opt,name=update_url,json=updateUrl,proto3" json:"update_url,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *MacAppsMetadata) Reset() {
	*x = MacAppsMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MacAppsMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MacAppsMetadata) ProtoMessage() {}

func (x *MacAppsMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MacAppsMetadata.ProtoReflect.Descriptor instead.
func (*MacAppsMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{29}
}

func (x *MacAppsMetadata) GetBundleDisplayName() string {
	if x != nil {
		return x.BundleDisplayName
	}
	return ""
}

func (x *MacAppsMetadata) GetBundleIdentifier() string {
	if x != nil {
		return x.BundleIdentifier
	}
	return ""
}

func (x *MacAppsMetadata) GetBundleShortVersionString() string {
	if x != nil {
		return x.BundleShortVersionString
	}
	return ""
}

func (x *MacAppsMetadata) GetBundleExecutable() string {
	if x != nil {
		return x.BundleExecutable
	}
	return ""
}

func (x *MacAppsMetadata) GetBundleName() string {
	if x != nil {
		return x.BundleName
	}
	return ""
}

func (x *MacAppsMetadata) GetBundlePackageType() string {
	if x != nil {
		return x.BundlePackageType
	}
	return ""
}

func (x *MacAppsMetadata) GetBundleSignature() string {
	if x != nil {
		return x.BundleSignature
	}
	return ""
}

func (x *MacAppsMetadata) GetBundleVersion() string {
	if x != nil {
		return x.BundleVersion
	}
	return ""
}

func (x *MacAppsMetadata) GetProductId() string {
	if x != nil {
		return x.ProductId
	}
	return ""
}

func (x *MacAppsMetadata) GetUpdateUrl() string {
	if x != nil {
		return x.UpdateUrl
	}
	return ""
}

// The additional data for packages extracted from SPDX files.
type SPDXPackageMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Purl          *Purl                  `protobuf:"bytes,1,opt,name=purl,proto3" json:"purl,omitempty"`
	Cpes          []string               `protobuf:"bytes,2,rep,name=cpes,proto3" json:"cpes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SPDXPackageMetadata) Reset() {
	*x = SPDXPackageMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SPDXPackageMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SPDXPackageMetadata) ProtoMessage() {}

func (x *SPDXPackageMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SPDXPackageMetadata.ProtoReflect.Descriptor instead.
func (*SPDXPackageMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{30}
}

func (x *SPDXPackageMetadata) GetPurl() *Purl {
	if x != nil {
		return x.Purl
	}
	return nil
}

func (x *SPDXPackageMetadata) GetCpes() []string {
	if x != nil {
		return x.Cpes
	}
	return nil
}

// The additional data for packages extracted from CDX files.
type CDXPackageMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Purl          *Purl                  `protobuf:"bytes,1,opt,name=purl,proto3" json:"purl,omitempty"`
	Cpes          []string               `protobuf:"bytes,2,rep,name=cpes,proto3" json:"cpes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CDXPackageMetadata) Reset() {
	*x = CDXPackageMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CDXPackageMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CDXPackageMetadata) ProtoMessage() {}

func (x *CDXPackageMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CDXPackageMetadata.ProtoReflect.Descriptor instead.
func (*CDXPackageMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{31}
}

func (x *CDXPackageMetadata) GetPurl() *Purl {
	if x != nil {
		return x.Purl
	}
	return nil
}

func (x *CDXPackageMetadata) GetCpes() []string {
	if x != nil {
		return x.Cpes
	}
	return nil
}

// The additional data found in Java JAR packages.
type JavaArchiveMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ArtifactId    string                 `protobuf:"bytes,2,opt,name=artifact_id,json=artifactId,proto3" json:"artifact_id,omitempty"`
	GroupId       string                 `protobuf:"bytes,3,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Sha1          string                 `protobuf:"bytes,4,opt,name=sha1,proto3" json:"sha1,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *JavaArchiveMetadata) Reset() {
	*x = JavaArchiveMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JavaArchiveMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JavaArchiveMetadata) ProtoMessage() {}

func (x *JavaArchiveMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JavaArchiveMetadata.ProtoReflect.Descriptor instead.
func (*JavaArchiveMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{32}
}

func (x *JavaArchiveMetadata) GetArtifactId() string {
	if x != nil {
		return x.ArtifactId
	}
	return ""
}

func (x *JavaArchiveMetadata) GetGroupId() string {
	if x != nil {
		return x.GroupId
	}
	return ""
}

func (x *JavaArchiveMetadata) GetSha1() string {
	if x != nil {
		return x.Sha1
	}
	return ""
}

// The additional data found in Java lockfiles.
type JavaLockfileMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ArtifactId    string                 `protobuf:"bytes,1,opt,name=artifact_id,json=artifactId,proto3" json:"artifact_id,omitempty"`
	GroupId       string                 `protobuf:"bytes,2,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	DepGroupVals  []string               `protobuf:"bytes,3,rep,name=dep_group_vals,json=depGroupVals,proto3" json:"dep_group_vals,omitempty"`
	IsTransitive  bool                   `protobuf:"varint,4,opt,name=is_transitive,json=isTransitive,proto3" json:"is_transitive,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *JavaLockfileMetadata) Reset() {
	*x = JavaLockfileMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JavaLockfileMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JavaLockfileMetadata) ProtoMessage() {}

func (x *JavaLockfileMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JavaLockfileMetadata.ProtoReflect.Descriptor instead.
func (*JavaLockfileMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{33}
}

func (x *JavaLockfileMetadata) GetArtifactId() string {
	if x != nil {
		return x.ArtifactId
	}
	return ""
}

func (x *JavaLockfileMetadata) GetGroupId() string {
	if x != nil {
		return x.GroupId
	}
	return ""
}

func (x *JavaLockfileMetadata) GetDepGroupVals() []string {
	if x != nil {
		return x.DepGroupVals
	}
	return nil
}

func (x *JavaLockfileMetadata) GetIsTransitive() bool {
	if x != nil {
		return x.IsTransitive
	}
	return false
}

// The additional data for packages extracted by an OSV extractor wrapper.
type OSVPackageMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PurlType      string                 `protobuf:"bytes,1,opt,name=purl_type,json=purlType,proto3" json:"purl_type,omitempty"`
	Commit        string                 `protobuf:"bytes,2,opt,name=commit,proto3" json:"commit,omitempty"`
	Ecosystem     string                 `protobuf:"bytes,3,opt,name=ecosystem,proto3" json:"ecosystem,omitempty"`
	CompareAs     string                 `protobuf:"bytes,4,opt,name=compare_as,json=compareAs,proto3" json:"compare_as,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OSVPackageMetadata) Reset() {
	*x = OSVPackageMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OSVPackageMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OSVPackageMetadata) ProtoMessage() {}

func (x *OSVPackageMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OSVPackageMetadata.ProtoReflect.Descriptor instead.
func (*OSVPackageMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{34}
}

func (x *OSVPackageMetadata) GetPurlType() string {
	if x != nil {
		return x.PurlType
	}
	return ""
}

func (x *OSVPackageMetadata) GetCommit() string {
	if x != nil {
		return x.Commit
	}
	return ""
}

func (x *OSVPackageMetadata) GetEcosystem() string {
	if x != nil {
		return x.Ecosystem
	}
	return ""
}

func (x *OSVPackageMetadata) GetCompareAs() string {
	if x != nil {
		return x.CompareAs
	}
	return ""
}

type PythonRequirementsMetadata struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	HashCheckingModeValues []string               `protobuf:"bytes,1,rep,name=hash_checking_mode_values,json=hashCheckingModeValues,proto3" json:"hash_checking_mode_values,omitempty"`
	VersionComparator      string                 `protobuf:"bytes,2,opt,name=version_comparator,json=versionComparator,proto3" json:"version_comparator,omitempty"`
	Requirement            string                 `protobuf:"bytes,3,opt,name=requirement,proto3" json:"requirement,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *PythonRequirementsMetadata) Reset() {
	*x = PythonRequirementsMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PythonRequirementsMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PythonRequirementsMetadata) ProtoMessage() {}

func (x *PythonRequirementsMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PythonRequirementsMetadata.ProtoReflect.Descriptor instead.
func (*PythonRequirementsMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{35}
}

func (x *PythonRequirementsMetadata) GetHashCheckingModeValues() []string {
	if x != nil {
		return x.HashCheckingModeValues
	}
	return nil
}

func (x *PythonRequirementsMetadata) GetVersionComparator() string {
	if x != nil {
		return x.VersionComparator
	}
	return ""
}

func (x *PythonRequirementsMetadata) GetRequirement() string {
	if x != nil {
		return x.Requirement
	}
	return ""
}

type PythonSetupMetadata struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	VersionComparator string                 `protobuf:"bytes,2,opt,name=version_comparator,json=versionComparator,proto3" json:"version_comparator,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *PythonSetupMetadata) Reset() {
	*x = PythonSetupMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PythonSetupMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PythonSetupMetadata) ProtoMessage() {}

func (x *PythonSetupMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PythonSetupMetadata.ProtoReflect.Descriptor instead.
func (*PythonSetupMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{36}
}

func (x *PythonSetupMetadata) GetVersionComparator() string {
	if x != nil {
		return x.VersionComparator
	}
	return ""
}

type ContainerdContainerMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NamespaceName string                 `protobuf:"bytes,1,opt,name=namespace_name,json=namespaceName,proto3" json:"namespace_name,omitempty"`
	ImageName     string                 `protobuf:"bytes,2,opt,name=image_name,json=imageName,proto3" json:"image_name,omitempty"`
	ImageDigest   string                 `protobuf:"bytes,3,opt,name=image_digest,json=imageDigest,proto3" json:"image_digest,omitempty"`
	Runtime       string                 `protobuf:"bytes,4,opt,name=runtime,proto3" json:"runtime,omitempty"`
	Pid           int32                  `protobuf:"varint,5,opt,name=pid,proto3" json:"pid,omitempty"`
	Snapshotter   string                 `protobuf:"bytes,6,opt,name=snapshotter,proto3" json:"snapshotter,omitempty"`
	SnapshotKey   string                 `protobuf:"bytes,7,opt,name=snapshot_key,json=snapshotKey,proto3" json:"snapshot_key,omitempty"`
	LowerDir      string                 `protobuf:"bytes,8,opt,name=lower_dir,json=lowerDir,proto3" json:"lower_dir,omitempty"`
	UpperDir      string                 `protobuf:"bytes,9,opt,name=upper_dir,json=upperDir,proto3" json:"upper_dir,omitempty"`
	WorkDir       string                 `protobuf:"bytes,10,opt,name=work_dir,json=workDir,proto3" json:"work_dir,omitempty"`
	Id            string                 `protobuf:"bytes,11,opt,name=id,proto3" json:"id,omitempty"`
	PodName       string                 `protobuf:"bytes,12,opt,name=pod_name,json=podName,proto3" json:"pod_name,omitempty"`
	PodNamespace  string                 `protobuf:"bytes,13,opt,name=pod_namespace,json=podNamespace,proto3" json:"pod_namespace,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContainerdContainerMetadata) Reset() {
	*x = ContainerdContainerMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContainerdContainerMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainerdContainerMetadata) ProtoMessage() {}

func (x *ContainerdContainerMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContainerdContainerMetadata.ProtoReflect.Descriptor instead.
func (*ContainerdContainerMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{37}
}

func (x *ContainerdContainerMetadata) GetNamespaceName() string {
	if x != nil {
		return x.NamespaceName
	}
	return ""
}

func (x *ContainerdContainerMetadata) GetImageName() string {
	if x != nil {
		return x.ImageName
	}
	return ""
}

func (x *ContainerdContainerMetadata) GetImageDigest() string {
	if x != nil {
		return x.ImageDigest
	}
	return ""
}

func (x *ContainerdContainerMetadata) GetRuntime() string {
	if x != nil {
		return x.Runtime
	}
	return ""
}

func (x *ContainerdContainerMetadata) GetPid() int32 {
	if x != nil {
		return x.Pid
	}
	return 0
}

func (x *ContainerdContainerMetadata) GetSnapshotter() string {
	if x != nil {
		return x.Snapshotter
	}
	return ""
}

func (x *ContainerdContainerMetadata) GetSnapshotKey() string {
	if x != nil {
		return x.SnapshotKey
	}
	return ""
}

func (x *ContainerdContainerMetadata) GetLowerDir() string {
	if x != nil {
		return x.LowerDir
	}
	return ""
}

func (x *ContainerdContainerMetadata) GetUpperDir() string {
	if x != nil {
		return x.UpperDir
	}
	return ""
}

func (x *ContainerdContainerMetadata) GetWorkDir() string {
	if x != nil {
		return x.WorkDir
	}
	return ""
}

func (x *ContainerdContainerMetadata) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ContainerdContainerMetadata) GetPodName() string {
	if x != nil {
		return x.PodName
	}
	return ""
}

func (x *ContainerdContainerMetadata) GetPodNamespace() string {
	if x != nil {
		return x.PodNamespace
	}
	return ""
}

type ContainerdRuntimeContainerMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NamespaceName string                 `protobuf:"bytes,1,opt,name=namespace_name,json=namespaceName,proto3" json:"namespace_name,omitempty"`
	ImageName     string                 `protobuf:"bytes,2,opt,name=image_name,json=imageName,proto3" json:"image_name,omitempty"`
	ImageDigest   string                 `protobuf:"bytes,3,opt,name=image_digest,json=imageDigest,proto3" json:"image_digest,omitempty"`
	Runtime       string                 `protobuf:"bytes,4,opt,name=runtime,proto3" json:"runtime,omitempty"`
	Id            string                 `protobuf:"bytes,5,opt,name=id,proto3" json:"id,omitempty"`
	Pid           int32                  `protobuf:"varint,6,opt,name=pid,proto3" json:"pid,omitempty"`
	RootfsPath    string                 `protobuf:"bytes,7,opt,name=rootfs_path,json=rootfsPath,proto3" json:"rootfs_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContainerdRuntimeContainerMetadata) Reset() {
	*x = ContainerdRuntimeContainerMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContainerdRuntimeContainerMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainerdRuntimeContainerMetadata) ProtoMessage() {}

func (x *ContainerdRuntimeContainerMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContainerdRuntimeContainerMetadata.ProtoReflect.Descriptor instead.
func (*ContainerdRuntimeContainerMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{38}
}

func (x *ContainerdRuntimeContainerMetadata) GetNamespaceName() string {
	if x != nil {
		return x.NamespaceName
	}
	return ""
}

func (x *ContainerdRuntimeContainerMetadata) GetImageName() string {
	if x != nil {
		return x.ImageName
	}
	return ""
}

func (x *ContainerdRuntimeContainerMetadata) GetImageDigest() string {
	if x != nil {
		return x.ImageDigest
	}
	return ""
}

func (x *ContainerdRuntimeContainerMetadata) GetRuntime() string {
	if x != nil {
		return x.Runtime
	}
	return ""
}

func (x *ContainerdRuntimeContainerMetadata) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ContainerdRuntimeContainerMetadata) GetPid() int32 {
	if x != nil {
		return x.Pid
	}
	return 0
}

func (x *ContainerdRuntimeContainerMetadata) GetRootfsPath() string {
	if x != nil {
		return x.RootfsPath
	}
	return ""
}

type WindowsOSVersion struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Product       string                 `protobuf:"bytes,1,opt,name=product,proto3" json:"product,omitempty"`
	FullVersion   string                 `protobuf:"bytes,2,opt,name=full_version,json=fullVersion,proto3" json:"full_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WindowsOSVersion) Reset() {
	*x = WindowsOSVersion{}
	mi := &file_proto_scan_result_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WindowsOSVersion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WindowsOSVersion) ProtoMessage() {}

func (x *WindowsOSVersion) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WindowsOSVersion.ProtoReflect.Descriptor instead.
func (*WindowsOSVersion) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{39}
}

func (x *WindowsOSVersion) GetProduct() string {
	if x != nil {
		return x.Product
	}
	return ""
}

func (x *WindowsOSVersion) GetFullVersion() string {
	if x != nil {
		return x.FullVersion
	}
	return ""
}

// The additional data found in Homebrew packages.
type HomebrewPackageMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HomebrewPackageMetadata) Reset() {
	*x = HomebrewPackageMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HomebrewPackageMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HomebrewPackageMetadata) ProtoMessage() {}

func (x *HomebrewPackageMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HomebrewPackageMetadata.ProtoReflect.Descriptor instead.
func (*HomebrewPackageMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{40}
}

// The additional data found in Chrome extensions.
type ChromeExtensionsMetadata struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	Name                 string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description          string                 `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	AuthorEmail          string                 `protobuf:"bytes,3,opt,name=author_email,json=authorEmail,proto3" json:"author_email,omitempty"`
	HostPermissions      []string               `protobuf:"bytes,4,rep,name=host_permissions,json=hostPermissions,proto3" json:"host_permissions,omitempty"`
	ManifestVersion      int32                  `protobuf:"varint,5,opt,name=manifest_version,json=manifestVersion,proto3" json:"manifest_version,omitempty"`
	MinimumChromeVersion string                 `protobuf:"bytes,6,opt,name=minimum_chrome_version,json=minimumChromeVersion,proto3" json:"minimum_chrome_version,omitempty"`
	Permissions          []string               `protobuf:"bytes,7,rep,name=permissions,proto3" json:"permissions,omitempty"`
	UpdateUrl            string                 `protobuf:"bytes,8,opt,name=update_url,json=updateUrl,proto3" json:"update_url,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *ChromeExtensionsMetadata) Reset() {
	*x = ChromeExtensionsMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChromeExtensionsMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChromeExtensionsMetadata) ProtoMessage() {}

func (x *ChromeExtensionsMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChromeExtensionsMetadata.ProtoReflect.Descriptor instead.
func (*ChromeExtensionsMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{41}
}

func (x *ChromeExtensionsMetadata) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ChromeExtensionsMetadata) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *ChromeExtensionsMetadata) GetAuthorEmail() string {
	if x != nil {
		return x.AuthorEmail
	}
	return ""
}

func (x *ChromeExtensionsMetadata) GetHostPermissions() []string {
	if x != nil {
		return x.HostPermissions
	}
	return nil
}

func (x *ChromeExtensionsMetadata) GetManifestVersion() int32 {
	if x != nil {
		return x.ManifestVersion
	}
	return 0
}

func (x *ChromeExtensionsMetadata) GetMinimumChromeVersion() string {
	if x != nil {
		return x.MinimumChromeVersion
	}
	return ""
}

func (x *ChromeExtensionsMetadata) GetPermissions() []string {
	if x != nil {
		return x.Permissions
	}
	return nil
}

func (x *ChromeExtensionsMetadata) GetUpdateUrl() string {
	if x != nil {
		return x.UpdateUrl
	}
	return ""
}

// The additional data found in VSCode extensions.
type VSCodeExtensionsMetadata struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	Id                   string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	PublisherId          string                 `protobuf:"bytes,2,opt,name=publisher_id,json=publisherId,proto3" json:"publisher_id,omitempty"`
	PublisherDisplayName string                 `protobuf:"bytes,3,opt,name=publisher_display_name,json=publisherDisplayName,proto3" json:"publisher_display_name,omitempty"`
	TargetPlatform       string                 `protobuf:"bytes,4,opt,name=target_platform,json=targetPlatform,proto3" json:"target_platform,omitempty"`
	Updated              bool                   `protobuf:"varint,5,opt,name=updated,proto3" json:"updated,omitempty"`
	IsPreReleaseVersion  bool                   `protobuf:"varint,6,opt,name=is_pre_release_version,json=isPreReleaseVersion,proto3" json:"is_pre_release_version,omitempty"`
	InstalledTimestamp   int64                  `protobuf:"varint,7,opt,name=installed_timestamp,json=installedTimestamp,proto3" json:"installed_timestamp,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *VSCodeExtensionsMetadata) Reset() {
	*x = VSCodeExtensionsMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VSCodeExtensionsMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VSCodeExtensionsMetadata) ProtoMessage() {}

func (x *VSCodeExtensionsMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VSCodeExtensionsMetadata.ProtoReflect.Descriptor instead.
func (*VSCodeExtensionsMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{42}
}

func (x *VSCodeExtensionsMetadata) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *VSCodeExtensionsMetadata) GetPublisherId() string {
	if x != nil {
		return x.PublisherId
	}
	return ""
}

func (x *VSCodeExtensionsMetadata) GetPublisherDisplayName() string {
	if x != nil {
		return x.PublisherDisplayName
	}
	return ""
}

func (x *VSCodeExtensionsMetadata) GetTargetPlatform() string {
	if x != nil {
		return x.TargetPlatform
	}
	return ""
}

func (x *VSCodeExtensionsMetadata) GetUpdated() bool {
	if x != nil {
		return x.Updated
	}
	return false
}

func (x *VSCodeExtensionsMetadata) GetIsPreReleaseVersion() bool {
	if x != nil {
		return x.IsPreReleaseVersion
	}
	return false
}

func (x *VSCodeExtensionsMetadata) GetInstalledTimestamp() int64 {
	if x != nil {
		return x.InstalledTimestamp
	}
	return 0
}

// The additional data found in Podman containers.
type PodmanMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ExposedPorts  map[uint32]*Protocol   `protobuf:"bytes,1,rep,name=exposed_ports,json=exposedPorts,proto3" json:"exposed_ports,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Pid           int32                  `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
	NamespaceName string                 `protobuf:"bytes,3,opt,name=namespace_name,json=namespaceName,proto3" json:"namespace_name,omitempty"`
	StartedTime   *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=started_time,json=startedTime,proto3" json:"started_time,omitempty"`
	FinishedTime  *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=finished_time,json=finishedTime,proto3" json:"finished_time,omitempty"`
	Status        string                 `protobuf:"bytes,6,opt,name=status,proto3" json:"status,omitempty"`
	ExitCode      int32                  `protobuf:"varint,7,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty"`
	Exited        bool                   `protobuf:"varint,8,opt,name=exited,proto3" json:"exited,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PodmanMetadata) Reset() {
	*x = PodmanMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PodmanMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PodmanMetadata) ProtoMessage() {}

func (x *PodmanMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PodmanMetadata.ProtoReflect.Descriptor instead.
func (*PodmanMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{43}
}

func (x *PodmanMetadata) GetExposedPorts() map[uint32]*Protocol {
	if x != nil {
		return x.ExposedPorts
	}
	return nil
}

func (x *PodmanMetadata) GetPid() int32 {
	if x != nil {
		return x.Pid
	}
	return 0
}

func (x *PodmanMetadata) GetNamespaceName() string {
	if x != nil {
		return x.NamespaceName
	}
	return ""
}

func (x *PodmanMetadata) GetStartedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartedTime
	}
	return nil
}

func (x *PodmanMetadata) GetFinishedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.FinishedTime
	}
	return nil
}

func (x *PodmanMetadata) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *PodmanMetadata) GetExitCode() int32 {
	if x != nil {
		return x.ExitCode
	}
	return 0
}

func (x *PodmanMetadata) GetExited() bool {
	if x != nil {
		return x.Exited
	}
	return false
}

type Protocol struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Names         []string               `protobuf:"bytes,1,rep,name=names,proto3" json:"names,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Protocol) Reset() {
	*x = Protocol{}
	mi := &file_proto_scan_result_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Protocol) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Protocol) ProtoMessage() {}

func (x *Protocol) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Protocol.ProtoReflect.Descriptor instead.
func (*Protocol) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{44}
}

func (x *Protocol) GetNames() []string {
	if x != nil {
		return x.Names
	}
	return nil
}

type DockerContainersMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ImageName     string                 `protobuf:"bytes,1,opt,name=image_name,json=imageName,proto3" json:"image_name,omitempty"`
	ImageDigest   string                 `protobuf:"bytes,2,opt,name=image_digest,json=imageDigest,proto3" json:"image_digest,omitempty"`
	Id            string                 `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	Ports         []*DockerPort          `protobuf:"bytes,4,rep,name=ports,proto3" json:"ports,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DockerContainersMetadata) Reset() {
	*x = DockerContainersMetadata{}
	mi := &file_proto_scan_result_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DockerContainersMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DockerContainersMetadata) ProtoMessage() {}

func (x *DockerContainersMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DockerContainersMetadata.ProtoReflect.Descriptor instead.
func (*DockerContainersMetadata) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{45}
}

func (x *DockerContainersMetadata) GetImageName() string {
	if x != nil {
		return x.ImageName
	}
	return ""
}

func (x *DockerContainersMetadata) GetImageDigest() string {
	if x != nil {
		return x.ImageDigest
	}
	return ""
}

func (x *DockerContainersMetadata) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *DockerContainersMetadata) GetPorts() []*DockerPort {
	if x != nil {
		return x.Ports
	}
	return nil
}

type DockerPort struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Ip            string                 `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	PrivatePort   uint32                 `protobuf:"varint,2,opt,name=private_port,json=privatePort,proto3" json:"private_port,omitempty"`
	PublicPort    uint32                 `protobuf:"varint,3,opt,name=public_port,json=publicPort,proto3" json:"public_port,omitempty"`
	Type          string                 `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DockerPort) Reset() {
	*x = DockerPort{}
	mi := &file_proto_scan_result_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DockerPort) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DockerPort) ProtoMessage() {}

func (x *DockerPort) ProtoReflect() protoreflect.Message {
	mi := &file_proto_scan_result_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DockerPort.ProtoReflect.Descriptor instead.
func (*DockerPort) Descriptor() ([]byte, []int) {
	return file_proto_scan_result_proto_rawDescGZIP(), []int{46}
}

func (x *DockerPort) GetIp() string {
	if x != nil {
		return x.Ip
	}
	return ""
}

func (x *DockerPort) GetPrivatePort() uint32 {
	if x != nil {
		return x.PrivatePort
	}
	return 0
}

func (x *DockerPort) GetPublicPort() uint32 {
	if x != nil {
		return x.PublicPort
	}
	return 0
}

func (x *DockerPort) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

var File_proto_scan_result_proto protoreflect.FileDescriptor

const file_proto_scan_result_proto_rawDesc = "" +
	"\n" +
	"\x17proto/scan_result.proto\x12\ascalibr\x1a\x1fgoogle/protobuf/timestamp.proto\"\xc7\x03\n" +
	"\n" +
	"ScanResult\x12\x18\n" +
	"\aversion\x18\x01 \x01(\tR\aversion\x129\n" +
	"\n" +
	"start_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\tstartTime\x125\n" +
	"\bend_time\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\aendTime\x12+\n" +
	"\x06status\x18\x04 \x01(\v2\x13.scalibr.ScanStatusR\x06status\x12:\n" +
	"\rplugin_status\x18\x05 \x03(\v2\x15.scalibr.PluginStatusR\fpluginStatus\x12K\n" +
	"\x16inventories_deprecated\x18\x06 \x03(\v2\x10.scalibr.PackageB\x02\x18\x01R\x15inventoriesDeprecated\x12E\n" +
	"\x13findings_deprecated\x18\a \x03(\v2\x10.scalibr.FindingB\x02\x18\x01R\x12findingsDeprecated\x120\n" +
	"\tinventory\x18\b \x01(\v2\x12.scalibr.InventoryR\tinventory\"g\n" +
	"\tInventory\x12,\n" +
	"\bpackages\x18\x01 \x03(\v2\x10.scalibr.PackageR\bpackages\x12,\n" +
	"\bfindings\x18\x02 \x03(\v2\x10.scalibr.FindingR\bfindings\"\xc6\x01\n" +
	"\n" +
	"ScanStatus\x12:\n" +
	"\x06status\x18\x01 \x01(\x0e2\".scalibr.ScanStatus.ScanStatusEnumR\x06status\x12%\n" +
	"\x0efailure_reason\x18\x02 \x01(\tR\rfailureReason\"U\n" +
	"\x0eScanStatusEnum\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\r\n" +
	"\tSUCCEEDED\x10\x01\x12\x17\n" +
	"\x13PARTIALLY_SUCCEEDED\x10\x02\x12\n" +
	"\n" +
	"\x06FAILED\x10\x03\"i\n" +
	"\fPluginStatus\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x02 \x01(\x05R\aversion\x12+\n" +
	"\x06status\x18\x03 \x01(\v2\x13.scalibr.ScanStatusR\x06status\"\xf6\x16\n" +
	"\aPackage\x12\x12\n" +
	"\x04name\x18\v \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\f \x01(\tR\aversion\x12>\n" +
	"\vsource_code\x18\x1a \x01(\v2\x1d.scalibr.SourceCodeIdentifierR\n" +
	"sourceCode\x12!\n" +
	"\x04purl\x18\x01 \x01(\v2\r.scalibr.PurlR\x04purl\x12\x1c\n" +
	"\tecosystem\x18\x1b \x01(\tR\tecosystem\x12\x1c\n" +
	"\tlocations\x18\x02 \x03(\tR\tlocations\x12\x1c\n" +
	"\textractor\x18\n" +
	" \x01(\tR\textractor\x12I\n" +
	"\x0fpython_metadata\x18\x05 \x01(\v2\x1e.scalibr.PythonPackageMetadataH\x00R\x0epythonMetadata\x12Y\n" +
	"\x13javascript_metadata\x18\x06 \x01(\v2&.scalibr.JavascriptPackageJSONMetadataH\x00R\x12javascriptMetadata\x12@\n" +
	"\fapk_metadata\x18\a \x01(\v2\x1b.scalibr.APKPackageMetadataH\x00R\vapkMetadata\x12C\n" +
	"\rdpkg_metadata\x18\b \x01(\v2\x1c.scalibr.DPKGPackageMetadataH\x00R\fdpkgMetadata\x12@\n" +
	"\frpm_metadata\x18\t \x01(\v2\x1b.scalibr.RPMPackageMetadataH\x00R\vrpmMetadata\x12@\n" +
	"\fcos_metadata\x18\r \x01(\v2\x1b.scalibr.COSPackageMetadataH\x00R\vcosMetadata\x12H\n" +
	"\x11depsjson_metadata\x18( \x01(\v2\x19.scalibr.DEPSJSONMetadataH\x00R\x10depsjsonMetadata\x12C\n" +
	"\rspdx_metadata\x18\x0e \x01(\v2\x1c.scalibr.SPDXPackageMetadataH\x00R\fspdxMetadata\x12R\n" +
	"\x15java_archive_metadata\x18\x0f \x01(\v2\x1c.scalibr.JavaArchiveMetadataH\x00R\x13javaArchiveMetadata\x12U\n" +
	"\x16java_lockfile_metadata\x18\x1f \x01(\v2\x1d.scalibr.JavaLockfileMetadataH\x00R\x14javaLockfileMetadata\x12I\n" +
	"\x0fpacman_metadata\x18$ \x01(\v2\x1e.scalibr.PACMANPackageMetadataH\x00R\x0epacmanMetadata\x12@\n" +
	"\fnix_metadata\x18% \x01(\v2\x1b.scalibr.NixPackageMetadataH\x00R\vnixMetadata\x12U\n" +
	"\x16kernel_module_metadata\x18& \x01(\v2\x1d.scalibr.KernelModuleMetadataH\x00R\x14kernelModuleMetadata\x12E\n" +
	"\x10vmlinuz_metadata\x18' \x01(\v2\x18.scalibr.VmlinuzMetadataH\x00R\x0fvmlinuzMetadata\x12L\n" +
	"\x10portage_metadata\x18) \x01(\v2\x1f.scalibr.PortagePackageMetadataH\x00R\x0fportageMetadata\x12@\n" +
	"\fosv_metadata\x18\x10 \x01(\v2\x1b.scalibr.OSVPackageMetadataH\x00R\vosvMetadata\x12g\n" +
	"\x1cpython_requirements_metadata\x18\x15 \x01(\v2#.scalibr.PythonRequirementsMetadataH\x00R\x1apythonRequirementsMetadata\x12R\n" +
	"\x15python_setup_metadata\x18, \x01(\v2\x1c.scalibr.PythonSetupMetadataH\x00R\x13pythonSetupMetadata\x12j\n" +
	"\x1dcontainerd_container_metadata\x18\x16 \x01(\v2$.scalibr.ContainerdContainerMetadataH\x00R\x1bcontainerdContainerMetadata\x12C\n" +
	"\rsnap_metadata\x18\x17 \x01(\v2\x1c.scalibr.SNAPPackageMetadataH\x00R\fsnapMetadata\x12L\n" +
	"\x10flatpak_metadata\x18\x18 \x01(\v2\x1f.scalibr.FlatpakPackageMetadataH\x00R\x0fflatpakMetadata\x12F\n" +
	"\x11mac_apps_metadata\x18\" \x01(\v2\x18.scalibr.MacAppsMetadataH\x00R\x0fmacAppsMetadata\x12\x80\x01\n" +
	"%containerd_runtime_container_metadata\x18\x19 \x01(\v2+.scalibr.ContainerdRuntimeContainerMetadataH\x00R\"containerdRuntimeContainerMetadata\x12@\n" +
	"\fcdx_metadata\x18\x1e \x01(\v2\x1b.scalibr.CDXPackageMetadataH\x00R\vcdxMetadata\x12Z\n" +
	"\x1bwindows_os_version_metadata\x18! \x01(\v2\x19.scalibr.WindowsOSVersionH\x00R\x18windowsOsVersionMetadata\x12O\n" +
	"\x11homebrew_metadata\x18* \x01(\v2 .scalibr.HomebrewPackageMetadataH\x00R\x10homebrewMetadata\x12a\n" +
	"\x1achrome_extensions_metadata\x18/ \x01(\v2!.scalibr.ChromeExtensionsMetadataH\x00R\x18chromeExtensionsMetadata\x12a\n" +
	"\x1avscode_extensions_metadata\x18. \x01(\v2!.scalibr.VSCodeExtensionsMetadataH\x00R\x18vscodeExtensionsMetadata\x12B\n" +
	"\x0fpodman_metadata\x182 \x01(\v2\x17.scalibr.PodmanMetadataH\x00R\x0epodmanMetadata\x12a\n" +
	"\x1adocker_containers_metadata\x180 \x01(\v2!.scalibr.DockerContainersMetadataH\x00R\x18dockerContainersMetadata\x12A\n" +
	"\vannotations\x18\x1c \x03(\x0e2\x1f.scalibr.Package.AnnotationEnumR\vannotations\x12:\n" +
	"\rlayer_details\x18# \x01(\v2\x15.scalibr.LayerDetailsR\flayerDetails\"`\n" +
	"\x0eAnnotationEnum\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\x10\n" +
	"\fTRANSITIONAL\x10\x01\x12\x15\n" +
	"\x11INSIDE_OS_PACKAGE\x10\x02\x12\x14\n" +
	"\x10INSIDE_CACHE_DIR\x10\x03B\n" +
	"\n" +
	"\bmetadataJ\x04\b\x03\x10\x04J\x04\b\x04\x10\x05\"B\n" +
	"\x14SourceCodeIdentifier\x12\x12\n" +
	"\x04repo\x18\x01 \x01(\tR\x04repo\x12\x16\n" +
	"\x06commit\x18\x02 \x01(\tR\x06commit\"\x96\x01\n" +
	"\fLayerDetails\x12\x14\n" +
	"\x05index\x18\x01 \x01(\x05R\x05index\x12\x17\n" +
	"\adiff_id\x18\x02 \x01(\tR\x06diffId\x12\x19\n" +
	"\bchain_id\x18\x05 \x01(\tR\achainId\x12\x18\n" +
	"\acommand\x18\x03 \x01(\tR\acommand\x12\"\n" +
	"\rin_base_image\x18\x04 \x01(\bR\vinBaseImage\"\xc8\x01\n" +
	"\x04Purl\x12\x12\n" +
	"\x04purl\x18\x01 \x01(\tR\x04purl\x12\x12\n" +
	"\x04type\x18\x02 \x01(\tR\x04type\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x04 \x01(\tR\aversion\x12\x1c\n" +
	"\tnamespace\x18\x05 \x01(\tR\tnamespace\x122\n" +
	"\n" +
	"qualifiers\x18\x06 \x03(\v2\x12.scalibr.QualifierR\n" +
	"qualifiers\x12\x18\n" +
	"\asubpath\x18\a \x01(\tR\asubpath\"3\n" +
	"\tQualifier\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\"\x92\x01\n" +
	"\aFinding\x12#\n" +
	"\x03adv\x18\x01 \x01(\v2\x11.scalibr.AdvisoryR\x03adv\x12.\n" +
	"\x06target\x18\x02 \x01(\v2\x16.scalibr.TargetDetailsR\x06target\x12\x14\n" +
	"\x05extra\x18\x03 \x01(\tR\x05extra\x12\x1c\n" +
	"\tdetectors\x18\x04 \x03(\tR\tdetectors\"\xa1\x02\n" +
	"\bAdvisory\x12#\n" +
	"\x02id\x18\x01 \x01(\v2\x13.scalibr.AdvisoryIdR\x02id\x12.\n" +
	"\x04type\x18\x02 \x01(\x0e2\x1a.scalibr.Advisory.TypeEnumR\x04type\x12\x14\n" +
	"\x05title\x18\x03 \x01(\tR\x05title\x12 \n" +
	"\vdescription\x18\x04 \x01(\tR\vdescription\x12&\n" +
	"\x0erecommendation\x18\x05 \x01(\tR\x0erecommendation\x12#\n" +
	"\x03sev\x18\x06 \x01(\v2\x11.scalibr.SeverityR\x03sev\";\n" +
	"\bTypeEnum\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\x11\n" +
	"\rVULNERABILITY\x10\x01\x12\x0f\n" +
	"\vCIS_FINDING\x10\x02\"H\n" +
	"\n" +
	"AdvisoryId\x12\x1c\n" +
	"\tpublisher\x18\x01 \x01(\tR\tpublisher\x12\x1c\n" +
	"\treference\x18\x02 \x01(\tR\treference\"\xf1\x01\n" +
	"\bSeverity\x12:\n" +
	"\bseverity\x18\x01 \x01(\x0e2\x1e.scalibr.Severity.SeverityEnumR\bseverity\x12&\n" +
	"\acvss_v2\x18\x02 \x01(\v2\r.scalibr.CVSSR\x06cvssV2\x12&\n" +
	"\acvss_v3\x18\x03 \x01(\v2\r.scalibr.CVSSR\x06cvssV3\"Y\n" +
	"\fSeverityEnum\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\v\n" +
	"\aMINIMAL\x10\x01\x12\a\n" +
	"\x03LOW\x10\x02\x12\n" +
	"\n" +
	"\x06MEDIUM\x10\x03\x12\b\n" +
	"\x04HIGH\x10\x04\x12\f\n" +
	"\bCRITICAL\x10\x05\"}\n" +
	"\x04CVSS\x12\x1d\n" +
	"\n" +
	"base_score\x18\x01 \x01(\x02R\tbaseScore\x12%\n" +
	"\x0etemporal_score\x18\x02 \x01(\x02R\rtemporalScore\x12/\n" +
	"\x13environmental_score\x18\x03 \x01(\x02R\x12environmentalScore\"W\n" +
	"\rTargetDetails\x12*\n" +
	"\apackage\x18\x01 \x01(\v2\x10.scalibr.PackageR\apackage\x12\x1a\n" +
	"\blocation\x18\x03 \x03(\tR\blocation\"R\n" +
	"\x15PythonPackageMetadata\x12\x16\n" +
	"\x06author\x18\x01 \x01(\tR\x06author\x12!\n" +
	"\fauthor_email\x18\x02 \x01(\tR\vauthorEmail\"}\n" +
	"\x1dJavascriptPackageJSONMetadata\x12\x16\n" +
	"\x06author\x18\x01 \x01(\tR\x06author\x12 \n" +
	"\vmaintainers\x18\x02 \x03(\tR\vmaintainers\x12\"\n" +
	"\fcontributors\x18\x03 \x03(\tR\fcontributors\"\xef\x01\n" +
	"\x12APKPackageMetadata\x12!\n" +
	"\fpackage_name\x18\x01 \x01(\tR\vpackageName\x12\x1f\n" +
	"\vorigin_name\x18\x02 \x01(\tR\n" +
	"originName\x12\x13\n" +
	"\x05os_id\x18\x03 \x01(\tR\x04osId\x12\"\n" +
	"\ros_version_id\x18\x04 \x01(\tR\vosVersionId\x12\x1e\n" +
	"\n" +
	"maintainer\x18\x05 \x01(\tR\n" +
	"maintainer\x12\"\n" +
	"\farchitecture\x18\x06 \x01(\tR\farchitecture\x12\x18\n" +
	"\alicense\x18\a \x01(\tR\alicense\"\xee\x02\n" +
	"\x13DPKGPackageMetadata\x12!\n" +
	"\fpackage_name\x18\x01 \x01(\tR\vpackageName\x12\x1f\n" +
	"\vsource_name\x18\x02 \x01(\tR\n" +
	"sourceName\x12%\n" +
	"\x0esource_version\x18\x03 \x01(\tR\rsourceVersion\x12'\n" +
	"\x0fpackage_version\x18\x04 \x01(\tR\x0epackageVersion\x12\x13\n" +
	"\x05os_id\x18\x05 \x01(\tR\x04osId\x12.\n" +
	"\x13os_version_codename\x18\x06 \x01(\tR\x11osVersionCodename\x12\"\n" +
	"\ros_version_id\x18\a \x01(\tR\vosVersionId\x12\x1e\n" +
	"\n" +
	"maintainer\x18\b \x01(\tR\n" +
	"maintainer\x12\"\n" +
	"\farchitecture\x18\t \x01(\tR\farchitecture\x12\x16\n" +
	"\x06status\x18\n" +
	" \x01(\tR\x06status\"\xb4\x02\n" +
	"\x12RPMPackageMetadata\x12!\n" +
	"\fpackage_name\x18\x01 \x01(\tR\vpackageName\x12\x1d\n" +
	"\n" +
	"source_rpm\x18\x02 \x01(\tR\tsourceRpm\x12\x14\n" +
	"\x05epoch\x18\x03 \x01(\x05R\x05epoch\x12\x13\n" +
	"\x05os_id\x18\x04 \x01(\tR\x04osId\x12\"\n" +
	"\ros_version_id\x18\x05 \x01(\tR\vosVersionId\x12\x1e\n" +
	"\vos_build_id\x18\x06 \x01(\tR\tosBuildId\x12\x17\n" +
	"\aos_name\x18\a \x01(\tR\x06osName\x12\x16\n" +
	"\x06vendor\x18\b \x01(\tR\x06vendor\x12\"\n" +
	"\farchitecture\x18\t \x01(\tR\farchitecture\x12\x18\n" +
	"\alicense\x18\n" +
	" \x01(\tR\alicense\"\xa1\x01\n" +
	"\x12COSPackageMetadata\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12\x1a\n" +
	"\bcategory\x18\x03 \x01(\tR\bcategory\x12\x1d\n" +
	"\n" +
	"os_version\x18\x04 \x01(\tR\tosVersion\x12\"\n" +
	"\ros_version_id\x18\x05 \x01(\tR\vosVersionId\"\x80\x02\n" +
	"\x15PACMANPackageMetadata\x12!\n" +
	"\fpackage_name\x18\x01 \x01(\tR\vpackageName\x12'\n" +
	"\x0fpackage_version\x18\x02 \x01(\tR\x0epackageVersion\x12\x13\n" +
	"\x05os_id\x18\x03 \x01(\tR\x04osId\x12\"\n" +
	"\ros_version_id\x18\x04 \x01(\tR\vosVersionId\x12/\n" +
	"\x13package_description\x18\x05 \x01(\tR\x12packageDescription\x121\n" +
	"\x14package_dependencies\x18\x06 \x01(\tR\x13packageDependencies\"\x93\x02\n" +
	"\x12NixPackageMetadata\x12!\n" +
	"\fpackage_name\x18\x01 \x01(\tR\vpackageName\x12'\n" +
	"\x0fpackage_version\x18\x02 \x01(\tR\x0epackageVersion\x12!\n" +
	"\fpackage_hash\x18\x03 \x01(\tR\vpackageHash\x12%\n" +
	"\x0epackage_output\x18\x04 \x01(\tR\rpackageOutput\x12\x13\n" +
	"\x05os_id\x18\x05 \x01(\tR\x04osId\x12.\n" +
	"\x13os_version_codename\x18\x06 \x01(\tR\x11osVersionCodename\x12\"\n" +
	"\ros_version_id\x18\a \x01(\tR\vosVersionId\"r\n" +
	"\x10DEPSJSONMetadata\x12!\n" +
	"\fpackage_name\x18\x01 \x01(\tR\vpackageName\x12'\n" +
	"\x0fpackage_version\x18\x02 \x01(\tR\x0epackageVersion\x12\x12\n" +
	"\x04type\x18\x03 \x01(\tR\x04type\"\xfc\x01\n" +
	"\x13SNAPPackageMetadata\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12\x14\n" +
	"\x05grade\x18\x03 \x01(\tR\x05grade\x12\x12\n" +
	"\x04type\x18\x04 \x01(\tR\x04type\x12$\n" +
	"\rarchitectures\x18\x05 \x03(\tR\rarchitectures\x12\x13\n" +
	"\x05os_id\x18\x06 \x01(\tR\x04osId\x12.\n" +
	"\x13os_version_codename\x18\a \x01(\tR\x11osVersionCodename\x12\"\n" +
	"\ros_version_id\x18\b \x01(\tR\vosVersionId\"\x9d\x01\n" +
	"\x16PortagePackageMetadata\x12!\n" +
	"\fpackage_name\x18\x01 \x01(\tR\vpackageName\x12'\n" +
	"\x0fpackage_version\x18\x02 \x01(\tR\x0epackageVersion\x12\x13\n" +
	"\x05os_id\x18\x03 \x01(\tR\x04osId\x12\"\n" +
	"\ros_version_id\x18\x04 \x01(\tR\vosVersionId\"\xb6\x02\n" +
	"\x16FlatpakPackageMetadata\x12!\n" +
	"\fpackage_name\x18\x01 \x01(\tR\vpackageName\x12\x1d\n" +
	"\n" +
	"package_id\x18\x02 \x01(\tR\tpackageId\x12'\n" +
	"\x0fpackage_version\x18\x03 \x01(\tR\x0epackageVersion\x12!\n" +
	"\frelease_date\x18\x04 \x01(\tR\vreleaseDate\x12\x17\n" +
	"\aos_name\x18\x05 \x01(\tR\x06osName\x12\x13\n" +
	"\x05os_id\x18\x06 \x01(\tR\x04osId\x12\"\n" +
	"\ros_version_id\x18\a \x01(\tR\vosVersionId\x12\x1e\n" +
	"\vos_build_id\x18\b \x01(\tR\tosBuildId\x12\x1c\n" +
	"\tdeveloper\x18\t \x01(\tR\tdeveloper\"\xe8\x02\n" +
	"\x14KernelModuleMetadata\x12!\n" +
	"\fpackage_name\x18\x01 \x01(\tR\vpackageName\x12'\n" +
	"\x0fpackage_version\x18\x02 \x01(\tR\x0epackageVersion\x12)\n" +
	"\x10package_vermagic\x18\x03 \x01(\tR\x0fpackageVermagic\x12I\n" +
	"!package_source_version_identifier\x18\x04 \x01(\tR\x1epackageSourceVersionIdentifier\x12\x13\n" +
	"\x05os_id\x18\x05 \x01(\tR\x04osId\x12.\n" +
	"\x13os_version_codename\x18\x06 \x01(\tR\x11osVersionCodename\x12\"\n" +
	"\ros_version_id\x18\a \x01(\tR\vosVersionId\x12%\n" +
	"\x0epackage_author\x18\b \x01(\tR\rpackageAuthor\"\x8e\x03\n" +
	"\x0fVmlinuzMetadata\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12\"\n" +
	"\farchitecture\x18\x03 \x01(\tR\farchitecture\x12)\n" +
	"\x10extended_version\x18\x04 \x01(\tR\x0fextendedVersion\x12\x16\n" +
	"\x06format\x18\x05 \x01(\tR\x06format\x12\x1f\n" +
	"\vswap_device\x18\x06 \x01(\x05R\n" +
	"swapDevice\x12\x1f\n" +
	"\vroot_device\x18\a \x01(\x05R\n" +
	"rootDevice\x12\x1d\n" +
	"\n" +
	"video_mode\x18\b \x01(\tR\tvideoMode\x12\x13\n" +
	"\x05os_id\x18\t \x01(\tR\x04osId\x12.\n" +
	"\x13os_version_codename\x18\n" +
	" \x01(\tR\x11osVersionCodename\x12\"\n" +
	"\ros_version_id\x18\v \x01(\tR\vosVersionId\x12\x1c\n" +
	"\n" +
	"rw_root_fs\x18\f \x01(\bR\brwRootFs\"\xbb\x03\n" +
	"\x0fMacAppsMetadata\x12.\n" +
	"\x13bundle_display_name\x18\x01 \x01(\tR\x11bundleDisplayName\x12+\n" +
	"\x11bundle_identifier\x18\x02 \x01(\tR\x10bundleIdentifier\x12=\n" +
	"\x1bbundle_short_version_string\x18\x03 \x01(\tR\x18bundleShortVersionString\x12+\n" +
	"\x11bundle_executable\x18\x04 \x01(\tR\x10bundleExecutable\x12\x1f\n" +
	"\vbundle_name\x18\x05 \x01(\tR\n" +
	"bundleName\x12.\n" +
	"\x13bundle_package_type\x18\x06 \x01(\tR\x11bundlePackageType\x12)\n" +
	"\x10bundle_signature\x18\a \x01(\tR\x0fbundleSignature\x12%\n" +
	"\x0ebundle_version\x18\b \x01(\tR\rbundleVersion\x12\x1d\n" +
	"\n" +
	"product_id\x18\t \x01(\tR\tproductId\x12\x1d\n" +
	"\n" +
	"update_url\x18\n" +
	" \x01(\tR\tupdateUrl\"L\n" +
	"\x13SPDXPackageMetadata\x12!\n" +
	"\x04purl\x18\x01 \x01(\v2\r.scalibr.PurlR\x04purl\x12\x12\n" +
	"\x04cpes\x18\x02 \x03(\tR\x04cpes\"K\n" +
	"\x12CDXPackageMetadata\x12!\n" +
	"\x04purl\x18\x01 \x01(\v2\r.scalibr.PurlR\x04purl\x12\x12\n" +
	"\x04cpes\x18\x02 \x03(\tR\x04cpes\"e\n" +
	"\x13JavaArchiveMetadata\x12\x1f\n" +
	"\vartifact_id\x18\x02 \x01(\tR\n" +
	"artifactId\x12\x19\n" +
	"\bgroup_id\x18\x03 \x01(\tR\agroupId\x12\x12\n" +
	"\x04sha1\x18\x04 \x01(\tR\x04sha1\"\x9d\x01\n" +
	"\x14JavaLockfileMetadata\x12\x1f\n" +
	"\vartifact_id\x18\x01 \x01(\tR\n" +
	"artifactId\x12\x19\n" +
	"\bgroup_id\x18\x02 \x01(\tR\agroupId\x12$\n" +
	"\x0edep_group_vals\x18\x03 \x03(\tR\fdepGroupVals\x12#\n" +
	"\ris_transitive\x18\x04 \x01(\bR\fisTransitive\"\x86\x01\n" +
	"\x12OSVPackageMetadata\x12\x1b\n" +
	"\tpurl_type\x18\x01 \x01(\tR\bpurlType\x12\x16\n" +
	"\x06commit\x18\x02 \x01(\tR\x06commit\x12\x1c\n" +
	"\tecosystem\x18\x03 \x01(\tR\tecosystem\x12\x1d\n" +
	"\n" +
	"compare_as\x18\x04 \x01(\tR\tcompareAs\"\xa8\x01\n" +
	"\x1aPythonRequirementsMetadata\x129\n" +
	"\x19hash_checking_mode_values\x18\x01 \x03(\tR\x16hashCheckingModeValues\x12-\n" +
	"\x12version_comparator\x18\x02 \x01(\tR\x11versionComparator\x12 \n" +
	"\vrequirement\x18\x03 \x01(\tR\vrequirement\"D\n" +
	"\x13PythonSetupMetadata\x12-\n" +
	"\x12version_comparator\x18\x02 \x01(\tR\x11versionComparator\"\x9c\x03\n" +
	"\x1bContainerdContainerMetadata\x12%\n" +
	"\x0enamespace_name\x18\x01 \x01(\tR\rnamespaceName\x12\x1d\n" +
	"\n" +
	"image_name\x18\x02 \x01(\tR\timageName\x12!\n" +
	"\fimage_digest\x18\x03 \x01(\tR\vimageDigest\x12\x18\n" +
	"\aruntime\x18\x04 \x01(\tR\aruntime\x12\x10\n" +
	"\x03pid\x18\x05 \x01(\x05R\x03pid\x12 \n" +
	"\vsnapshotter\x18\x06 \x01(\tR\vsnapshotter\x12!\n" +
	"\fsnapshot_key\x18\a \x01(\tR\vsnapshotKey\x12\x1b\n" +
	"\tlower_dir\x18\b \x01(\tR\blowerDir\x12\x1b\n" +
	"\tupper_dir\x18\t \x01(\tR\bupperDir\x12\x19\n" +
	"\bwork_dir\x18\n" +
	" \x01(\tR\aworkDir\x12\x0e\n" +
	"\x02id\x18\v \x01(\tR\x02id\x12\x19\n" +
	"\bpod_name\x18\f \x01(\tR\apodName\x12#\n" +
	"\rpod_namespace\x18\r \x01(\tR\fpodNamespace\"\xea\x01\n" +
	"\"ContainerdRuntimeContainerMetadata\x12%\n" +
	"\x0enamespace_name\x18\x01 \x01(\tR\rnamespaceName\x12\x1d\n" +
	"\n" +
	"image_name\x18\x02 \x01(\tR\timageName\x12!\n" +
	"\fimage_digest\x18\x03 \x01(\tR\vimageDigest\x12\x18\n" +
	"\aruntime\x18\x04 \x01(\tR\aruntime\x12\x0e\n" +
	"\x02id\x18\x05 \x01(\tR\x02id\x12\x10\n" +
	"\x03pid\x18\x06 \x01(\x05R\x03pid\x12\x1f\n" +
	"\vrootfs_path\x18\a \x01(\tR\n" +
	"rootfsPath\"O\n" +
	"\x10WindowsOSVersion\x12\x18\n" +
	"\aproduct\x18\x01 \x01(\tR\aproduct\x12!\n" +
	"\ffull_version\x18\x02 \x01(\tR\vfullVersion\"\x19\n" +
	"\x17HomebrewPackageMetadata\"\xc0\x02\n" +
	"\x18ChromeExtensionsMetadata\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x02 \x01(\tR\vdescription\x12!\n" +
	"\fauthor_email\x18\x03 \x01(\tR\vauthorEmail\x12)\n" +
	"\x10host_permissions\x18\x04 \x03(\tR\x0fhostPermissions\x12)\n" +
	"\x10manifest_version\x18\x05 \x01(\x05R\x0fmanifestVersion\x124\n" +
	"\x16minimum_chrome_version\x18\x06 \x01(\tR\x14minimumChromeVersion\x12 \n" +
	"\vpermissions\x18\a \x03(\tR\vpermissions\x12\x1d\n" +
	"\n" +
	"update_url\x18\b \x01(\tR\tupdateUrl\"\xac\x02\n" +
	"\x18VSCodeExtensionsMetadata\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12!\n" +
	"\fpublisher_id\x18\x02 \x01(\tR\vpublisherId\x124\n" +
	"\x16publisher_display_name\x18\x03 \x01(\tR\x14publisherDisplayName\x12'\n" +
	"\x0ftarget_platform\x18\x04 \x01(\tR\x0etargetPlatform\x12\x18\n" +
	"\aupdated\x18\x05 \x01(\bR\aupdated\x123\n" +
	"\x16is_pre_release_version\x18\x06 \x01(\bR\x13isPreReleaseVersion\x12/\n" +
	"\x13installed_timestamp\x18\a \x01(\x03R\x12installedTimestamp\"\xba\x03\n" +
	"\x0ePodmanMetadata\x12N\n" +
	"\rexposed_ports\x18\x01 \x03(\v2).scalibr.PodmanMetadata.ExposedPortsEntryR\fexposedPorts\x12\x10\n" +
	"\x03pid\x18\x02 \x01(\x05R\x03pid\x12%\n" +
	"\x0enamespace_name\x18\x03 \x01(\tR\rnamespaceName\x12=\n" +
	"\fstarted_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\vstartedTime\x12?\n" +
	"\rfinished_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\ffinishedTime\x12\x16\n" +
	"\x06status\x18\x06 \x01(\tR\x06status\x12\x1b\n" +
	"\texit_code\x18\a \x01(\x05R\bexitCode\x12\x16\n" +
	"\x06exited\x18\b \x01(\bR\x06exited\x1aR\n" +
	"\x11ExposedPortsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\rR\x03key\x12'\n" +
	"\x05value\x18\x02 \x01(\v2\x11.scalibr.ProtocolR\x05value:\x028\x01\" \n" +
	"\bProtocol\x12\x14\n" +
	"\x05names\x18\x01 \x03(\tR\x05names\"\x97\x01\n" +
	"\x18DockerContainersMetadata\x12\x1d\n" +
	"\n" +
	"image_name\x18\x01 \x01(\tR\timageName\x12!\n" +
	"\fimage_digest\x18\x02 \x01(\tR\vimageDigest\x12\x0e\n" +
	"\x02id\x18\x03 \x01(\tR\x02id\x12)\n" +
	"\x05ports\x18\x04 \x03(\v2\x13.scalibr.DockerPortR\x05ports\"t\n" +
	"\n" +
	"DockerPort\x12\x0e\n" +
	"\x02ip\x18\x01 \x01(\tR\x02ip\x12!\n" +
	"\fprivate_port\x18\x02 \x01(\rR\vprivatePort\x12\x1f\n" +
	"\vpublic_port\x18\x03 \x01(\rR\n" +
	"publicPort\x12\x12\n" +
	"\x04type\x18\x04 \x01(\tR\x04typeB?P\x01Z;github.com/google/scalibr/binary/proto/scan_result_go_protob\x06proto3"

var (
	file_proto_scan_result_proto_rawDescOnce sync.Once
	file_proto_scan_result_proto_rawDescData []byte
)

func file_proto_scan_result_proto_rawDescGZIP() []byte {
	file_proto_scan_result_proto_rawDescOnce.Do(func() {
		file_proto_scan_result_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_scan_result_proto_rawDesc), len(file_proto_scan_result_proto_rawDesc)))
	})
	return file_proto_scan_result_proto_rawDescData
}

var file_proto_scan_result_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_proto_scan_result_proto_msgTypes = make([]protoimpl.MessageInfo, 48)
var file_proto_scan_result_proto_goTypes = []any{
	(ScanStatus_ScanStatusEnum)(0),             // 0: scalibr.ScanStatus.ScanStatusEnum
	(Package_AnnotationEnum)(0),                // 1: scalibr.Package.AnnotationEnum
	(Advisory_TypeEnum)(0),                     // 2: scalibr.Advisory.TypeEnum
	(Severity_SeverityEnum)(0),                 // 3: scalibr.Severity.SeverityEnum
	(*ScanResult)(nil),                         // 4: scalibr.ScanResult
	(*Inventory)(nil),                          // 5: scalibr.Inventory
	(*ScanStatus)(nil),                         // 6: scalibr.ScanStatus
	(*PluginStatus)(nil),                       // 7: scalibr.PluginStatus
	(*Package)(nil),                            // 8: scalibr.Package
	(*SourceCodeIdentifier)(nil),               // 9: scalibr.SourceCodeIdentifier
	(*LayerDetails)(nil),                       // 10: scalibr.LayerDetails
	(*Purl)(nil),                               // 11: scalibr.Purl
	(*Qualifier)(nil),                          // 12: scalibr.Qualifier
	(*Finding)(nil),                            // 13: scalibr.Finding
	(*Advisory)(nil),                           // 14: scalibr.Advisory
	(*AdvisoryId)(nil),                         // 15: scalibr.AdvisoryId
	(*Severity)(nil),                           // 16: scalibr.Severity
	(*CVSS)(nil),                               // 17: scalibr.CVSS
	(*TargetDetails)(nil),                      // 18: scalibr.TargetDetails
	(*PythonPackageMetadata)(nil),              // 19: scalibr.PythonPackageMetadata
	(*JavascriptPackageJSONMetadata)(nil),      // 20: scalibr.JavascriptPackageJSONMetadata
	(*APKPackageMetadata)(nil),                 // 21: scalibr.APKPackageMetadata
	(*DPKGPackageMetadata)(nil),                // 22: scalibr.DPKGPackageMetadata
	(*RPMPackageMetadata)(nil),                 // 23: scalibr.RPMPackageMetadata
	(*COSPackageMetadata)(nil),                 // 24: scalibr.COSPackageMetadata
	(*PACMANPackageMetadata)(nil),              // 25: scalibr.PACMANPackageMetadata
	(*NixPackageMetadata)(nil),                 // 26: scalibr.NixPackageMetadata
	(*DEPSJSONMetadata)(nil),                   // 27: scalibr.DEPSJSONMetadata
	(*SNAPPackageMetadata)(nil),                // 28: scalibr.SNAPPackageMetadata
	(*PortagePackageMetadata)(nil),             // 29: scalibr.PortagePackageMetadata
	(*FlatpakPackageMetadata)(nil),             // 30: scalibr.FlatpakPackageMetadata
	(*KernelModuleMetadata)(nil),               // 31: scalibr.KernelModuleMetadata
	(*VmlinuzMetadata)(nil),                    // 32: scalibr.VmlinuzMetadata
	(*MacAppsMetadata)(nil),                    // 33: scalibr.MacAppsMetadata
	(*SPDXPackageMetadata)(nil),                // 34: scalibr.SPDXPackageMetadata
	(*CDXPackageMetadata)(nil),                 // 35: scalibr.CDXPackageMetadata
	(*JavaArchiveMetadata)(nil),                // 36: scalibr.JavaArchiveMetadata
	(*JavaLockfileMetadata)(nil),               // 37: scalibr.JavaLockfileMetadata
	(*OSVPackageMetadata)(nil),                 // 38: scalibr.OSVPackageMetadata
	(*PythonRequirementsMetadata)(nil),         // 39: scalibr.PythonRequirementsMetadata
	(*PythonSetupMetadata)(nil),                // 40: scalibr.PythonSetupMetadata
	(*ContainerdContainerMetadata)(nil),        // 41: scalibr.ContainerdContainerMetadata
	(*ContainerdRuntimeContainerMetadata)(nil), // 42: scalibr.ContainerdRuntimeContainerMetadata
	(*WindowsOSVersion)(nil),                   // 43: scalibr.WindowsOSVersion
	(*HomebrewPackageMetadata)(nil),            // 44: scalibr.HomebrewPackageMetadata
	(*ChromeExtensionsMetadata)(nil),           // 45: scalibr.ChromeExtensionsMetadata
	(*VSCodeExtensionsMetadata)(nil),           // 46: scalibr.VSCodeExtensionsMetadata
	(*PodmanMetadata)(nil),                     // 47: scalibr.PodmanMetadata
	(*Protocol)(nil),                           // 48: scalibr.Protocol
	(*DockerContainersMetadata)(nil),           // 49: scalibr.DockerContainersMetadata
	(*DockerPort)(nil),                         // 50: scalibr.DockerPort
	nil,                                        // 51: scalibr.PodmanMetadata.ExposedPortsEntry
	(*timestamppb.Timestamp)(nil),              // 52: google.protobuf.Timestamp
}
var file_proto_scan_result_proto_depIdxs = []int32{
	52, // 0: scalibr.ScanResult.start_time:type_name -> google.protobuf.Timestamp
	52, // 1: scalibr.ScanResult.end_time:type_name -> google.protobuf.Timestamp
	6,  // 2: scalibr.ScanResult.status:type_name -> scalibr.ScanStatus
	7,  // 3: scalibr.ScanResult.plugin_status:type_name -> scalibr.PluginStatus
	8,  // 4: scalibr.ScanResult.inventories_deprecated:type_name -> scalibr.Package
	13, // 5: scalibr.ScanResult.findings_deprecated:type_name -> scalibr.Finding
	5,  // 6: scalibr.ScanResult.inventory:type_name -> scalibr.Inventory
	8,  // 7: scalibr.Inventory.packages:type_name -> scalibr.Package
	13, // 8: scalibr.Inventory.findings:type_name -> scalibr.Finding
	0,  // 9: scalibr.ScanStatus.status:type_name -> scalibr.ScanStatus.ScanStatusEnum
	6,  // 10: scalibr.PluginStatus.status:type_name -> scalibr.ScanStatus
	9,  // 11: scalibr.Package.source_code:type_name -> scalibr.SourceCodeIdentifier
	11, // 12: scalibr.Package.purl:type_name -> scalibr.Purl
	19, // 13: scalibr.Package.python_metadata:type_name -> scalibr.PythonPackageMetadata
	20, // 14: scalibr.Package.javascript_metadata:type_name -> scalibr.JavascriptPackageJSONMetadata
	21, // 15: scalibr.Package.apk_metadata:type_name -> scalibr.APKPackageMetadata
	22, // 16: scalibr.Package.dpkg_metadata:type_name -> scalibr.DPKGPackageMetadata
	23, // 17: scalibr.Package.rpm_metadata:type_name -> scalibr.RPMPackageMetadata
	24, // 18: scalibr.Package.cos_metadata:type_name -> scalibr.COSPackageMetadata
	27, // 19: scalibr.Package.depsjson_metadata:type_name -> scalibr.DEPSJSONMetadata
	34, // 20: scalibr.Package.spdx_metadata:type_name -> scalibr.SPDXPackageMetadata
	36, // 21: scalibr.Package.java_archive_metadata:type_name -> scalibr.JavaArchiveMetadata
	37, // 22: scalibr.Package.java_lockfile_metadata:type_name -> scalibr.JavaLockfileMetadata
	25, // 23: scalibr.Package.pacman_metadata:type_name -> scalibr.PACMANPackageMetadata
	26, // 24: scalibr.Package.nix_metadata:type_name -> scalibr.NixPackageMetadata
	31, // 25: scalibr.Package.kernel_module_metadata:type_name -> scalibr.KernelModuleMetadata
	32, // 26: scalibr.Package.vmlinuz_metadata:type_name -> scalibr.VmlinuzMetadata
	29, // 27: scalibr.Package.portage_metadata:type_name -> scalibr.PortagePackageMetadata
	38, // 28: scalibr.Package.osv_metadata:type_name -> scalibr.OSVPackageMetadata
	39, // 29: scalibr.Package.python_requirements_metadata:type_name -> scalibr.PythonRequirementsMetadata
	40, // 30: scalibr.Package.python_setup_metadata:type_name -> scalibr.PythonSetupMetadata
	41, // 31: scalibr.Package.containerd_container_metadata:type_name -> scalibr.ContainerdContainerMetadata
	28, // 32: scalibr.Package.snap_metadata:type_name -> scalibr.SNAPPackageMetadata
	30, // 33: scalibr.Package.flatpak_metadata:type_name -> scalibr.FlatpakPackageMetadata
	33, // 34: scalibr.Package.mac_apps_metadata:type_name -> scalibr.MacAppsMetadata
	42, // 35: scalibr.Package.containerd_runtime_container_metadata:type_name -> scalibr.ContainerdRuntimeContainerMetadata
	35, // 36: scalibr.Package.cdx_metadata:type_name -> scalibr.CDXPackageMetadata
	43, // 37: scalibr.Package.windows_os_version_metadata:type_name -> scalibr.WindowsOSVersion
	44, // 38: scalibr.Package.homebrew_metadata:type_name -> scalibr.HomebrewPackageMetadata
	45, // 39: scalibr.Package.chrome_extensions_metadata:type_name -> scalibr.ChromeExtensionsMetadata
	46, // 40: scalibr.Package.vscode_extensions_metadata:type_name -> scalibr.VSCodeExtensionsMetadata
	47, // 41: scalibr.Package.podman_metadata:type_name -> scalibr.PodmanMetadata
	49, // 42: scalibr.Package.docker_containers_metadata:type_name -> scalibr.DockerContainersMetadata
	1,  // 43: scalibr.Package.annotations:type_name -> scalibr.Package.AnnotationEnum
	10, // 44: scalibr.Package.layer_details:type_name -> scalibr.LayerDetails
	12, // 45: scalibr.Purl.qualifiers:type_name -> scalibr.Qualifier
	14, // 46: scalibr.Finding.adv:type_name -> scalibr.Advisory
	18, // 47: scalibr.Finding.target:type_name -> scalibr.TargetDetails
	15, // 48: scalibr.Advisory.id:type_name -> scalibr.AdvisoryId
	2,  // 49: scalibr.Advisory.type:type_name -> scalibr.Advisory.TypeEnum
	16, // 50: scalibr.Advisory.sev:type_name -> scalibr.Severity
	3,  // 51: scalibr.Severity.severity:type_name -> scalibr.Severity.SeverityEnum
	17, // 52: scalibr.Severity.cvss_v2:type_name -> scalibr.CVSS
	17, // 53: scalibr.Severity.cvss_v3:type_name -> scalibr.CVSS
	8,  // 54: scalibr.TargetDetails.package:type_name -> scalibr.Package
	11, // 55: scalibr.SPDXPackageMetadata.purl:type_name -> scalibr.Purl
	11, // 56: scalibr.CDXPackageMetadata.purl:type_name -> scalibr.Purl
	51, // 57: scalibr.PodmanMetadata.exposed_ports:type_name -> scalibr.PodmanMetadata.ExposedPortsEntry
	52, // 58: scalibr.PodmanMetadata.started_time:type_name -> google.protobuf.Timestamp
	52, // 59: scalibr.PodmanMetadata.finished_time:type_name -> google.protobuf.Timestamp
	50, // 60: scalibr.DockerContainersMetadata.ports:type_name -> scalibr.DockerPort
	48, // 61: scalibr.PodmanMetadata.ExposedPortsEntry.value:type_name -> scalibr.Protocol
	62, // [62:62] is the sub-list for method output_type
	62, // [62:62] is the sub-list for method input_type
	62, // [62:62] is the sub-list for extension type_name
	62, // [62:62] is the sub-list for extension extendee
	0,  // [0:62] is the sub-list for field type_name
}

func init() { file_proto_scan_result_proto_init() }
func file_proto_scan_result_proto_init() {
	if File_proto_scan_result_proto != nil {
		return
	}
	file_proto_scan_result_proto_msgTypes[4].OneofWrappers = []any{
		(*Package_PythonMetadata)(nil),
		(*Package_JavascriptMetadata)(nil),
		(*Package_ApkMetadata)(nil),
		(*Package_DpkgMetadata)(nil),
		(*Package_RpmMetadata)(nil),
		(*Package_CosMetadata)(nil),
		(*Package_DepsjsonMetadata)(nil),
		(*Package_SpdxMetadata)(nil),
		(*Package_JavaArchiveMetadata)(nil),
		(*Package_JavaLockfileMetadata)(nil),
		(*Package_PacmanMetadata)(nil),
		(*Package_NixMetadata)(nil),
		(*Package_KernelModuleMetadata)(nil),
		(*Package_VmlinuzMetadata)(nil),
		(*Package_PortageMetadata)(nil),
		(*Package_OsvMetadata)(nil),
		(*Package_PythonRequirementsMetadata)(nil),
		(*Package_PythonSetupMetadata)(nil),
		(*Package_ContainerdContainerMetadata)(nil),
		(*Package_SnapMetadata)(nil),
		(*Package_FlatpakMetadata)(nil),
		(*Package_MacAppsMetadata)(nil),
		(*Package_ContainerdRuntimeContainerMetadata)(nil),
		(*Package_CdxMetadata)(nil),
		(*Package_WindowsOsVersionMetadata)(nil),
		(*Package_HomebrewMetadata)(nil),
		(*Package_ChromeExtensionsMetadata)(nil),
		(*Package_VscodeExtensionsMetadata)(nil),
		(*Package_PodmanMetadata)(nil),
		(*Package_DockerContainersMetadata)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_scan_result_proto_rawDesc), len(file_proto_scan_result_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   48,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_scan_result_proto_goTypes,
		DependencyIndexes: file_proto_scan_result_proto_depIdxs,
		EnumInfos:         file_proto_scan_result_proto_enumTypes,
		MessageInfos:      file_proto_scan_result_proto_msgTypes,
	}.Build()
	File_proto_scan_result_proto = out.File
	file_proto_scan_result_proto_goTypes = nil
	file_proto_scan_result_proto_depIdxs = nil
}
