//
// Copyright 2026 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.31.1
// source: proto/config.proto

package config_go_proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type PluginConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	// The local directory to store the downloaded manifests during dependency
	// resolution.
	LocalRegistry string `protobuf:"bytes,3,opt,name=local_registry,json=localRegistry,proto3" json:"local_registry,omitempty"`
	// If true, do not try to create google.DefaultClient for Artifact Registry
	// during dependency resolution.
	DisableGoogleAuth bool `protobuf:"varint,4,opt,name=disable_google_auth,json=disableGoogleAuth,proto3" json:"disable_google_auth,omitempty"`
	// The user agent to use when making requests.
	UserAgent string `protobuf:"bytes,5,opt,name=user_agent,json=userAgent,proto3" json:"user_agent,omitempty"`
	// Config values that only apply to a single plugin.
	PluginSpecific []*PluginSpecificConfig `protobuf:"bytes,2,rep,name=plugin_specific,json=pluginSpecific,proto3" json:"plugin_specific,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *PluginConfig) Reset() {
	*x = PluginConfig{}
	mi := &file_proto_config_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PluginConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PluginConfig) ProtoMessage() {}

func (x *PluginConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PluginConfig.ProtoReflect.Descriptor instead.
func (*PluginConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{0}
}

func (x *PluginConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

func (x *PluginConfig) GetLocalRegistry() string {
	if x != nil {
		return x.LocalRegistry
	}
	return ""
}

func (x *PluginConfig) GetDisableGoogleAuth() bool {
	if x != nil {
		return x.DisableGoogleAuth
	}
	return false
}

func (x *PluginConfig) GetUserAgent() string {
	if x != nil {
		return x.UserAgent
	}
	return ""
}

func (x *PluginConfig) GetPluginSpecific() []*PluginSpecificConfig {
	if x != nil {
		return x.PluginSpecific
	}
	return nil
}

type PluginSpecificConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Config:
	//
	//	*PluginSpecificConfig_GoBinary
	//	*PluginSpecificConfig_Govulncheck
	//	*PluginSpecificConfig_Archive
	//	*PluginSpecificConfig_Ova
	//	*PluginSpecificConfig_Vdi
	//	*PluginSpecificConfig_Vmdk
	//	*PluginSpecificConfig_HashicorpVaultValidator
	//	*PluginSpecificConfig_SdpInspect
	//	*PluginSpecificConfig_PomXmlNet
	//	*PluginSpecificConfig_Chocolatey
	//	*PluginSpecificConfig_Dpkg
	//	*PluginSpecificConfig_Rpm
	//	*PluginSpecificConfig_Apk
	//	*PluginSpecificConfig_Cos
	//	*PluginSpecificConfig_Snap
	//	*PluginSpecificConfig_KernelModule
	//	*PluginSpecificConfig_Vmlinuz
	//	*PluginSpecificConfig_Pacman
	//	*PluginSpecificConfig_Portage
	//	*PluginSpecificConfig_Flatpak
	//	*PluginSpecificConfig_Macapps
	//	*PluginSpecificConfig_Podman
	//	*PluginSpecificConfig_DockerBaseImage
	//	*PluginSpecificConfig_Containerd
	//	*PluginSpecificConfig_DockerComposeImage
	//	*PluginSpecificConfig_K8SImage
	//	*PluginSpecificConfig_DotnetDepsJson
	//	*PluginSpecificConfig_DotnetPackagesConfig
	//	*PluginSpecificConfig_DotnetPackagesLockJson
	//	*PluginSpecificConfig_DotnetPe
	//	*PluginSpecificConfig_Gemspec
	//	*PluginSpecificConfig_CargoAuditable
	//	*PluginSpecificConfig_SwiftPackageResolved
	//	*PluginSpecificConfig_SwiftPodfileLock
	//	*PluginSpecificConfig_ElixirMixLock
	//	*PluginSpecificConfig_HaskellStacklock
	//	*PluginSpecificConfig_HaskellCabal
	//	*PluginSpecificConfig_JavaArchive
	//	*PluginSpecificConfig_JavascriptPackageJson
	//	*PluginSpecificConfig_JavascriptPackageLockJson
	//	*PluginSpecificConfig_PythonRequirements
	//	*PluginSpecificConfig_PythonSetup
	//	*PluginSpecificConfig_PythonCondameta
	//	*PluginSpecificConfig_PythonWheelEgg
	//	*PluginSpecificConfig_GoMod
	//	*PluginSpecificConfig_WordpressPlugins
	//	*PluginSpecificConfig_Mariadb
	//	*PluginSpecificConfig_Osvlocal
	Config        isPluginSpecificConfig_Config `protobuf_oneof:"config"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PluginSpecificConfig) Reset() {
	*x = PluginSpecificConfig{}
	mi := &file_proto_config_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PluginSpecificConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PluginSpecificConfig) ProtoMessage() {}

func (x *PluginSpecificConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PluginSpecificConfig.ProtoReflect.Descriptor instead.
func (*PluginSpecificConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{1}
}

func (x *PluginSpecificConfig) GetConfig() isPluginSpecificConfig_Config {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *PluginSpecificConfig) GetGoBinary() *GoBinaryConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_GoBinary); ok {
			return x.GoBinary
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetGovulncheck() *GovulncheckConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Govulncheck); ok {
			return x.Govulncheck
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetArchive() *ArchiveConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Archive); ok {
			return x.Archive
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetOva() *OVAConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Ova); ok {
			return x.Ova
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetVdi() *VDIConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Vdi); ok {
			return x.Vdi
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetVmdk() *VMDKConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Vmdk); ok {
			return x.Vmdk
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetHashicorpVaultValidator() *HashiCorpVaultValidatorConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_HashicorpVaultValidator); ok {
			return x.HashicorpVaultValidator
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetSdpInspect() *SDPInspectConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_SdpInspect); ok {
			return x.SdpInspect
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetPomXmlNet() *POMXMLNetConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_PomXmlNet); ok {
			return x.PomXmlNet
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetChocolatey() *ChocolateyConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Chocolatey); ok {
			return x.Chocolatey
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetDpkg() *DpkgConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Dpkg); ok {
			return x.Dpkg
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetRpm() *RpmConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Rpm); ok {
			return x.Rpm
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetApk() *ApkConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Apk); ok {
			return x.Apk
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetCos() *CosConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Cos); ok {
			return x.Cos
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetSnap() *SnapConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Snap); ok {
			return x.Snap
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetKernelModule() *KernelModuleConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_KernelModule); ok {
			return x.KernelModule
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetVmlinuz() *VmlinuzConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Vmlinuz); ok {
			return x.Vmlinuz
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetPacman() *PacmanConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Pacman); ok {
			return x.Pacman
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetPortage() *PortageConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Portage); ok {
			return x.Portage
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetFlatpak() *FlatpakConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Flatpak); ok {
			return x.Flatpak
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetMacapps() *MacAppsConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Macapps); ok {
			return x.Macapps
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetPodman() *PodmanConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Podman); ok {
			return x.Podman
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetDockerBaseImage() *DockerBaseImageConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_DockerBaseImage); ok {
			return x.DockerBaseImage
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetContainerd() *ContainerdConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Containerd); ok {
			return x.Containerd
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetDockerComposeImage() *DockerComposeImageConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_DockerComposeImage); ok {
			return x.DockerComposeImage
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetK8SImage() *K8SImageConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_K8SImage); ok {
			return x.K8SImage
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetDotnetDepsJson() *DotnetDepsJsonConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_DotnetDepsJson); ok {
			return x.DotnetDepsJson
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetDotnetPackagesConfig() *DotnetPackagesConfigConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_DotnetPackagesConfig); ok {
			return x.DotnetPackagesConfig
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetDotnetPackagesLockJson() *DotnetPackagesLockJsonConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_DotnetPackagesLockJson); ok {
			return x.DotnetPackagesLockJson
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetDotnetPe() *DotnetPeConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_DotnetPe); ok {
			return x.DotnetPe
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetGemspec() *GemspecConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Gemspec); ok {
			return x.Gemspec
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetCargoAuditable() *CargoAuditableConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_CargoAuditable); ok {
			return x.CargoAuditable
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetSwiftPackageResolved() *SwiftPackageResolvedConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_SwiftPackageResolved); ok {
			return x.SwiftPackageResolved
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetSwiftPodfileLock() *SwiftPodfileLockConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_SwiftPodfileLock); ok {
			return x.SwiftPodfileLock
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetElixirMixLock() *ElixirMixLockConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_ElixirMixLock); ok {
			return x.ElixirMixLock
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetHaskellStacklock() *HaskellStacklockConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_HaskellStacklock); ok {
			return x.HaskellStacklock
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetHaskellCabal() *HaskellCabalConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_HaskellCabal); ok {
			return x.HaskellCabal
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetJavaArchive() *JavaArchiveConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_JavaArchive); ok {
			return x.JavaArchive
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetJavascriptPackageJson() *JavascriptPackageJsonConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_JavascriptPackageJson); ok {
			return x.JavascriptPackageJson
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetJavascriptPackageLockJson() *JavascriptPackageLockJsonConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_JavascriptPackageLockJson); ok {
			return x.JavascriptPackageLockJson
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetPythonRequirements() *PythonRequirementsConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_PythonRequirements); ok {
			return x.PythonRequirements
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetPythonSetup() *PythonSetupConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_PythonSetup); ok {
			return x.PythonSetup
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetPythonCondameta() *PythonCondametaConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_PythonCondameta); ok {
			return x.PythonCondameta
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetPythonWheelEgg() *PythonWheelEggConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_PythonWheelEgg); ok {
			return x.PythonWheelEgg
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetGoMod() *GoModConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_GoMod); ok {
			return x.GoMod
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetWordpressPlugins() *WordpressPluginsConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_WordpressPlugins); ok {
			return x.WordpressPlugins
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetMariadb() *MariadbConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Mariadb); ok {
			return x.Mariadb
		}
	}
	return nil
}

func (x *PluginSpecificConfig) GetOsvlocal() *OSVLocalConfig {
	if x != nil {
		if x, ok := x.Config.(*PluginSpecificConfig_Osvlocal); ok {
			return x.Osvlocal
		}
	}
	return nil
}

type isPluginSpecificConfig_Config interface {
	isPluginSpecificConfig_Config()
}

type PluginSpecificConfig_GoBinary struct {
	GoBinary *GoBinaryConfig `protobuf:"bytes,1,opt,name=go_binary,json=goBinary,proto3,oneof"`
}

type PluginSpecificConfig_Govulncheck struct {
	Govulncheck *GovulncheckConfig `protobuf:"bytes,2,opt,name=govulncheck,proto3,oneof"`
}

type PluginSpecificConfig_Archive struct {
	Archive *ArchiveConfig `protobuf:"bytes,3,opt,name=archive,proto3,oneof"`
}

type PluginSpecificConfig_Ova struct {
	Ova *OVAConfig `protobuf:"bytes,4,opt,name=ova,proto3,oneof"`
}

type PluginSpecificConfig_Vdi struct {
	Vdi *VDIConfig `protobuf:"bytes,5,opt,name=vdi,proto3,oneof"`
}

type PluginSpecificConfig_Vmdk struct {
	Vmdk *VMDKConfig `protobuf:"bytes,6,opt,name=vmdk,proto3,oneof"`
}

type PluginSpecificConfig_HashicorpVaultValidator struct {
	HashicorpVaultValidator *HashiCorpVaultValidatorConfig `protobuf:"bytes,7,opt,name=hashicorp_vault_validator,json=hashicorpVaultValidator,proto3,oneof"`
}

type PluginSpecificConfig_SdpInspect struct {
	SdpInspect *SDPInspectConfig `protobuf:"bytes,8,opt,name=sdp_inspect,json=sdpInspect,proto3,oneof"`
}

type PluginSpecificConfig_PomXmlNet struct {
	PomXmlNet *POMXMLNetConfig `protobuf:"bytes,9,opt,name=pom_xml_net,json=pomXmlNet,proto3,oneof"`
}

type PluginSpecificConfig_Chocolatey struct {
	Chocolatey *ChocolateyConfig `protobuf:"bytes,10,opt,name=chocolatey,proto3,oneof"`
}

type PluginSpecificConfig_Dpkg struct {
	Dpkg *DpkgConfig `protobuf:"bytes,11,opt,name=dpkg,proto3,oneof"`
}

type PluginSpecificConfig_Rpm struct {
	Rpm *RpmConfig `protobuf:"bytes,12,opt,name=rpm,proto3,oneof"`
}

type PluginSpecificConfig_Apk struct {
	Apk *ApkConfig `protobuf:"bytes,13,opt,name=apk,proto3,oneof"`
}

type PluginSpecificConfig_Cos struct {
	Cos *CosConfig `protobuf:"bytes,14,opt,name=cos,proto3,oneof"`
}

type PluginSpecificConfig_Snap struct {
	Snap *SnapConfig `protobuf:"bytes,15,opt,name=snap,proto3,oneof"`
}

type PluginSpecificConfig_KernelModule struct {
	KernelModule *KernelModuleConfig `protobuf:"bytes,16,opt,name=kernel_module,json=kernelModule,proto3,oneof"`
}

type PluginSpecificConfig_Vmlinuz struct {
	Vmlinuz *VmlinuzConfig `protobuf:"bytes,17,opt,name=vmlinuz,proto3,oneof"`
}

type PluginSpecificConfig_Pacman struct {
	Pacman *PacmanConfig `protobuf:"bytes,18,opt,name=pacman,proto3,oneof"`
}

type PluginSpecificConfig_Portage struct {
	Portage *PortageConfig `protobuf:"bytes,19,opt,name=portage,proto3,oneof"`
}

type PluginSpecificConfig_Flatpak struct {
	Flatpak *FlatpakConfig `protobuf:"bytes,20,opt,name=flatpak,proto3,oneof"`
}

type PluginSpecificConfig_Macapps struct {
	Macapps *MacAppsConfig `protobuf:"bytes,21,opt,name=macapps,proto3,oneof"`
}

type PluginSpecificConfig_Podman struct {
	Podman *PodmanConfig `protobuf:"bytes,22,opt,name=podman,proto3,oneof"`
}

type PluginSpecificConfig_DockerBaseImage struct {
	DockerBaseImage *DockerBaseImageConfig `protobuf:"bytes,23,opt,name=docker_base_image,json=dockerBaseImage,proto3,oneof"`
}

type PluginSpecificConfig_Containerd struct {
	Containerd *ContainerdConfig `protobuf:"bytes,24,opt,name=containerd,proto3,oneof"`
}

type PluginSpecificConfig_DockerComposeImage struct {
	DockerComposeImage *DockerComposeImageConfig `protobuf:"bytes,25,opt,name=docker_compose_image,json=dockerComposeImage,proto3,oneof"`
}

type PluginSpecificConfig_K8SImage struct {
	K8SImage *K8SImageConfig `protobuf:"bytes,26,opt,name=k8s_image,json=k8sImage,proto3,oneof"`
}

type PluginSpecificConfig_DotnetDepsJson struct {
	DotnetDepsJson *DotnetDepsJsonConfig `protobuf:"bytes,27,opt,name=dotnet_deps_json,json=dotnetDepsJson,proto3,oneof"`
}

type PluginSpecificConfig_DotnetPackagesConfig struct {
	DotnetPackagesConfig *DotnetPackagesConfigConfig `protobuf:"bytes,28,opt,name=dotnet_packages_config,json=dotnetPackagesConfig,proto3,oneof"`
}

type PluginSpecificConfig_DotnetPackagesLockJson struct {
	DotnetPackagesLockJson *DotnetPackagesLockJsonConfig `protobuf:"bytes,29,opt,name=dotnet_packages_lock_json,json=dotnetPackagesLockJson,proto3,oneof"`
}

type PluginSpecificConfig_DotnetPe struct {
	DotnetPe *DotnetPeConfig `protobuf:"bytes,30,opt,name=dotnet_pe,json=dotnetPe,proto3,oneof"`
}

type PluginSpecificConfig_Gemspec struct {
	Gemspec *GemspecConfig `protobuf:"bytes,31,opt,name=gemspec,proto3,oneof"`
}

type PluginSpecificConfig_CargoAuditable struct {
	CargoAuditable *CargoAuditableConfig `protobuf:"bytes,32,opt,name=cargo_auditable,json=cargoAuditable,proto3,oneof"`
}

type PluginSpecificConfig_SwiftPackageResolved struct {
	SwiftPackageResolved *SwiftPackageResolvedConfig `protobuf:"bytes,33,opt,name=swift_package_resolved,json=swiftPackageResolved,proto3,oneof"`
}

type PluginSpecificConfig_SwiftPodfileLock struct {
	SwiftPodfileLock *SwiftPodfileLockConfig `protobuf:"bytes,34,opt,name=swift_podfile_lock,json=swiftPodfileLock,proto3,oneof"`
}

type PluginSpecificConfig_ElixirMixLock struct {
	ElixirMixLock *ElixirMixLockConfig `protobuf:"bytes,35,opt,name=elixir_mix_lock,json=elixirMixLock,proto3,oneof"`
}

type PluginSpecificConfig_HaskellStacklock struct {
	HaskellStacklock *HaskellStacklockConfig `protobuf:"bytes,36,opt,name=haskell_stacklock,json=haskellStacklock,proto3,oneof"`
}

type PluginSpecificConfig_HaskellCabal struct {
	HaskellCabal *HaskellCabalConfig `protobuf:"bytes,37,opt,name=haskell_cabal,json=haskellCabal,proto3,oneof"`
}

type PluginSpecificConfig_JavaArchive struct {
	JavaArchive *JavaArchiveConfig `protobuf:"bytes,38,opt,name=java_archive,json=javaArchive,proto3,oneof"`
}

type PluginSpecificConfig_JavascriptPackageJson struct {
	JavascriptPackageJson *JavascriptPackageJsonConfig `protobuf:"bytes,39,opt,name=javascript_package_json,json=javascriptPackageJson,proto3,oneof"`
}

type PluginSpecificConfig_JavascriptPackageLockJson struct {
	JavascriptPackageLockJson *JavascriptPackageLockJsonConfig `protobuf:"bytes,40,opt,name=javascript_package_lock_json,json=javascriptPackageLockJson,proto3,oneof"`
}

type PluginSpecificConfig_PythonRequirements struct {
	PythonRequirements *PythonRequirementsConfig `protobuf:"bytes,41,opt,name=python_requirements,json=pythonRequirements,proto3,oneof"`
}

type PluginSpecificConfig_PythonSetup struct {
	PythonSetup *PythonSetupConfig `protobuf:"bytes,42,opt,name=python_setup,json=pythonSetup,proto3,oneof"`
}

type PluginSpecificConfig_PythonCondameta struct {
	PythonCondameta *PythonCondametaConfig `protobuf:"bytes,43,opt,name=python_condameta,json=pythonCondameta,proto3,oneof"`
}

type PluginSpecificConfig_PythonWheelEgg struct {
	PythonWheelEgg *PythonWheelEggConfig `protobuf:"bytes,44,opt,name=python_wheel_egg,json=pythonWheelEgg,proto3,oneof"`
}

type PluginSpecificConfig_GoMod struct {
	GoMod *GoModConfig `protobuf:"bytes,45,opt,name=go_mod,json=goMod,proto3,oneof"`
}

type PluginSpecificConfig_WordpressPlugins struct {
	WordpressPlugins *WordpressPluginsConfig `protobuf:"bytes,46,opt,name=wordpress_plugins,json=wordpressPlugins,proto3,oneof"`
}

type PluginSpecificConfig_Mariadb struct {
	Mariadb *MariadbConfig `protobuf:"bytes,47,opt,name=mariadb,proto3,oneof"`
}

type PluginSpecificConfig_Osvlocal struct {
	Osvlocal *OSVLocalConfig `protobuf:"bytes,57,opt,name=osvlocal,proto3,oneof"`
}

func (*PluginSpecificConfig_GoBinary) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Govulncheck) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Archive) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Ova) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Vdi) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Vmdk) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_HashicorpVaultValidator) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_SdpInspect) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_PomXmlNet) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Chocolatey) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Dpkg) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Rpm) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Apk) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Cos) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Snap) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_KernelModule) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Vmlinuz) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Pacman) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Portage) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Flatpak) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Macapps) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Podman) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_DockerBaseImage) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Containerd) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_DockerComposeImage) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_K8SImage) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_DotnetDepsJson) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_DotnetPackagesConfig) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_DotnetPackagesLockJson) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_DotnetPe) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Gemspec) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_CargoAuditable) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_SwiftPackageResolved) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_SwiftPodfileLock) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_ElixirMixLock) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_HaskellStacklock) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_HaskellCabal) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_JavaArchive) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_JavascriptPackageJson) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_JavascriptPackageLockJson) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_PythonRequirements) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_PythonSetup) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_PythonCondameta) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_PythonWheelEgg) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_GoMod) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_WordpressPlugins) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Mariadb) isPluginSpecificConfig_Config() {}

func (*PluginSpecificConfig_Osvlocal) isPluginSpecificConfig_Config() {}

type GoBinaryConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enables extracting the module version from the Go binary content.
	VersionFromContent bool `protobuf:"varint,1,opt,name=version_from_content,json=versionFromContent,proto3" json:"version_from_content,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *GoBinaryConfig) Reset() {
	*x = GoBinaryConfig{}
	mi := &file_proto_config_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GoBinaryConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GoBinaryConfig) ProtoMessage() {}

func (x *GoBinaryConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GoBinaryConfig.ProtoReflect.Descriptor instead.
func (*GoBinaryConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{2}
}

func (x *GoBinaryConfig) GetVersionFromContent() bool {
	if x != nil {
		return x.VersionFromContent
	}
	return false
}

type GovulncheckConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Path to the offline vuln DB to pass to govunlcheck. If empty,
	// the detector will query vulns from the net instead.
	OfflineVulnDbPath string `protobuf:"bytes,1,opt,name=offline_vuln_db_path,json=offlineVulnDbPath,proto3" json:"offline_vuln_db_path,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *GovulncheckConfig) Reset() {
	*x = GovulncheckConfig{}
	mi := &file_proto_config_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GovulncheckConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GovulncheckConfig) ProtoMessage() {}

func (x *GovulncheckConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GovulncheckConfig.ProtoReflect.Descriptor instead.
func (*GovulncheckConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{3}
}

func (x *GovulncheckConfig) GetOfflineVulnDbPath() string {
	if x != nil {
		return x.OfflineVulnDbPath
	}
	return ""
}

type ArchiveConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ArchiveConfig) Reset() {
	*x = ArchiveConfig{}
	mi := &file_proto_config_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ArchiveConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ArchiveConfig) ProtoMessage() {}

func (x *ArchiveConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ArchiveConfig.ProtoReflect.Descriptor instead.
func (*ArchiveConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{4}
}

func (x *ArchiveConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type OVAConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *OVAConfig) Reset() {
	*x = OVAConfig{}
	mi := &file_proto_config_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OVAConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OVAConfig) ProtoMessage() {}

func (x *OVAConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OVAConfig.ProtoReflect.Descriptor instead.
func (*OVAConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{5}
}

func (x *OVAConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type VDIConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *VDIConfig) Reset() {
	*x = VDIConfig{}
	mi := &file_proto_config_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VDIConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VDIConfig) ProtoMessage() {}

func (x *VDIConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VDIConfig.ProtoReflect.Descriptor instead.
func (*VDIConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{6}
}

func (x *VDIConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type VMDKConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *VMDKConfig) Reset() {
	*x = VMDKConfig{}
	mi := &file_proto_config_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VMDKConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VMDKConfig) ProtoMessage() {}

func (x *VMDKConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VMDKConfig.ProtoReflect.Descriptor instead.
func (*VMDKConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{7}
}

func (x *VMDKConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type ChocolateyConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ChocolateyConfig) Reset() {
	*x = ChocolateyConfig{}
	mi := &file_proto_config_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChocolateyConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChocolateyConfig) ProtoMessage() {}

func (x *ChocolateyConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChocolateyConfig.ProtoReflect.Descriptor instead.
func (*ChocolateyConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{8}
}

func (x *ChocolateyConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type HashiCorpVaultValidatorConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The URL of the Vault server to connect to.
	// https://developer.hashicorp.com/vault
	VaultUrl      string `protobuf:"bytes,1,opt,name=vault_url,json=vaultUrl,proto3" json:"vault_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HashiCorpVaultValidatorConfig) Reset() {
	*x = HashiCorpVaultValidatorConfig{}
	mi := &file_proto_config_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HashiCorpVaultValidatorConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HashiCorpVaultValidatorConfig) ProtoMessage() {}

func (x *HashiCorpVaultValidatorConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HashiCorpVaultValidatorConfig.ProtoReflect.Descriptor instead.
func (*HashiCorpVaultValidatorConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{9}
}

func (x *HashiCorpVaultValidatorConfig) GetVaultUrl() string {
	if x != nil {
		return x.VaultUrl
	}
	return ""
}

type SDPInspectConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The GCP project id to use for Sensitive Data Protection InspectContent API
	// calls.
	ProjectId     string `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SDPInspectConfig) Reset() {
	*x = SDPInspectConfig{}
	mi := &file_proto_config_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SDPInspectConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SDPInspectConfig) ProtoMessage() {}

func (x *SDPInspectConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SDPInspectConfig.ProtoReflect.Descriptor instead.
func (*SDPInspectConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{10}
}

func (x *SDPInspectConfig) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

type POMXMLNetConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The URL of the upstream Maven registry.
	UpstreamRegistry string `protobuf:"bytes,1,opt,name=upstream_registry,json=upstreamRegistry,proto3" json:"upstream_registry,omitempty"`
	// If true, use deps.dev requirements API for dependency resolution.
	DepsDevRequirements bool `protobuf:"varint,2,opt,name=deps_dev_requirements,json=depsDevRequirements,proto3" json:"deps_dev_requirements,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *POMXMLNetConfig) Reset() {
	*x = POMXMLNetConfig{}
	mi := &file_proto_config_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *POMXMLNetConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*POMXMLNetConfig) ProtoMessage() {}

func (x *POMXMLNetConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use POMXMLNetConfig.ProtoReflect.Descriptor instead.
func (*POMXMLNetConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{11}
}

func (x *POMXMLNetConfig) GetUpstreamRegistry() string {
	if x != nil {
		return x.UpstreamRegistry
	}
	return ""
}

func (x *POMXMLNetConfig) GetDepsDevRequirements() bool {
	if x != nil {
		return x.DepsDevRequirements
	}
	return false
}

type DpkgConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Includes packages that are not installed
	// (e.g. `deinstall`, `purge`, and those missing a status field).
	IncludeNotInstalled bool `protobuf:"varint,1,opt,name=include_not_installed,json=includeNotInstalled,proto3" json:"include_not_installed,omitempty"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,2,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *DpkgConfig) Reset() {
	*x = DpkgConfig{}
	mi := &file_proto_config_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DpkgConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DpkgConfig) ProtoMessage() {}

func (x *DpkgConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DpkgConfig.ProtoReflect.Descriptor instead.
func (*DpkgConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{12}
}

func (x *DpkgConfig) GetIncludeNotInstalled() bool {
	if x != nil {
		return x.IncludeNotInstalled
	}
	return false
}

func (x *DpkgConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type RpmConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Timeout in seconds for parsing the RPM database.
	TimeoutSeconds int64 `protobuf:"varint,1,opt,name=timeout_seconds,json=timeoutSeconds,proto3" json:"timeout_seconds,omitempty"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,2,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *RpmConfig) Reset() {
	*x = RpmConfig{}
	mi := &file_proto_config_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RpmConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RpmConfig) ProtoMessage() {}

func (x *RpmConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RpmConfig.ProtoReflect.Descriptor instead.
func (*RpmConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{13}
}

func (x *RpmConfig) GetTimeoutSeconds() int64 {
	if x != nil {
		return x.TimeoutSeconds
	}
	return 0
}

func (x *RpmConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type ApkConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ApkConfig) Reset() {
	*x = ApkConfig{}
	mi := &file_proto_config_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApkConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApkConfig) ProtoMessage() {}

func (x *ApkConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApkConfig.ProtoReflect.Descriptor instead.
func (*ApkConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{14}
}

func (x *ApkConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type CosConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *CosConfig) Reset() {
	*x = CosConfig{}
	mi := &file_proto_config_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CosConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CosConfig) ProtoMessage() {}

func (x *CosConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CosConfig.ProtoReflect.Descriptor instead.
func (*CosConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{15}
}

func (x *CosConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type SnapConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *SnapConfig) Reset() {
	*x = SnapConfig{}
	mi := &file_proto_config_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SnapConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SnapConfig) ProtoMessage() {}

func (x *SnapConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SnapConfig.ProtoReflect.Descriptor instead.
func (*SnapConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{16}
}

func (x *SnapConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type KernelModuleConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *KernelModuleConfig) Reset() {
	*x = KernelModuleConfig{}
	mi := &file_proto_config_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KernelModuleConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KernelModuleConfig) ProtoMessage() {}

func (x *KernelModuleConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KernelModuleConfig.ProtoReflect.Descriptor instead.
func (*KernelModuleConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{17}
}

func (x *KernelModuleConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type VmlinuzConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *VmlinuzConfig) Reset() {
	*x = VmlinuzConfig{}
	mi := &file_proto_config_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VmlinuzConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VmlinuzConfig) ProtoMessage() {}

func (x *VmlinuzConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VmlinuzConfig.ProtoReflect.Descriptor instead.
func (*VmlinuzConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{18}
}

func (x *VmlinuzConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type PacmanConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *PacmanConfig) Reset() {
	*x = PacmanConfig{}
	mi := &file_proto_config_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PacmanConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PacmanConfig) ProtoMessage() {}

func (x *PacmanConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PacmanConfig.ProtoReflect.Descriptor instead.
func (*PacmanConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{19}
}

func (x *PacmanConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type PortageConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *PortageConfig) Reset() {
	*x = PortageConfig{}
	mi := &file_proto_config_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PortageConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PortageConfig) ProtoMessage() {}

func (x *PortageConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PortageConfig.ProtoReflect.Descriptor instead.
func (*PortageConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{20}
}

func (x *PortageConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type FlatpakConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *FlatpakConfig) Reset() {
	*x = FlatpakConfig{}
	mi := &file_proto_config_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlatpakConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlatpakConfig) ProtoMessage() {}

func (x *FlatpakConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlatpakConfig.ProtoReflect.Descriptor instead.
func (*FlatpakConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{21}
}

func (x *FlatpakConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type MacAppsConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *MacAppsConfig) Reset() {
	*x = MacAppsConfig{}
	mi := &file_proto_config_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MacAppsConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MacAppsConfig) ProtoMessage() {}

func (x *MacAppsConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MacAppsConfig.ProtoReflect.Descriptor instead.
func (*MacAppsConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{22}
}

func (x *MacAppsConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type PodmanConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Specifies whether to list all containers, including those
	// that are not currently running.
	IncludeStopped bool `protobuf:"varint,1,opt,name=include_stopped,json=includeStopped,proto3" json:"include_stopped,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *PodmanConfig) Reset() {
	*x = PodmanConfig{}
	mi := &file_proto_config_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PodmanConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PodmanConfig) ProtoMessage() {}

func (x *PodmanConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PodmanConfig.ProtoReflect.Descriptor instead.
func (*PodmanConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{23}
}

func (x *PodmanConfig) GetIncludeStopped() bool {
	if x != nil {
		return x.IncludeStopped
	}
	return false
}

type DockerBaseImageConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *DockerBaseImageConfig) Reset() {
	*x = DockerBaseImageConfig{}
	mi := &file_proto_config_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DockerBaseImageConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DockerBaseImageConfig) ProtoMessage() {}

func (x *DockerBaseImageConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DockerBaseImageConfig.ProtoReflect.Descriptor instead.
func (*DockerBaseImageConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{24}
}

func (x *DockerBaseImageConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type ContainerdConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ContainerdConfig) Reset() {
	*x = ContainerdConfig{}
	mi := &file_proto_config_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContainerdConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainerdConfig) ProtoMessage() {}

func (x *ContainerdConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContainerdConfig.ProtoReflect.Descriptor instead.
func (*ContainerdConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{25}
}

func (x *ContainerdConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type DockerComposeImageConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *DockerComposeImageConfig) Reset() {
	*x = DockerComposeImageConfig{}
	mi := &file_proto_config_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DockerComposeImageConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DockerComposeImageConfig) ProtoMessage() {}

func (x *DockerComposeImageConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DockerComposeImageConfig.ProtoReflect.Descriptor instead.
func (*DockerComposeImageConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{26}
}

func (x *DockerComposeImageConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type K8SImageConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *K8SImageConfig) Reset() {
	*x = K8SImageConfig{}
	mi := &file_proto_config_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *K8SImageConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*K8SImageConfig) ProtoMessage() {}

func (x *K8SImageConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use K8SImageConfig.ProtoReflect.Descriptor instead.
func (*K8SImageConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{27}
}

func (x *K8SImageConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type DotnetDepsJsonConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *DotnetDepsJsonConfig) Reset() {
	*x = DotnetDepsJsonConfig{}
	mi := &file_proto_config_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DotnetDepsJsonConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DotnetDepsJsonConfig) ProtoMessage() {}

func (x *DotnetDepsJsonConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DotnetDepsJsonConfig.ProtoReflect.Descriptor instead.
func (*DotnetDepsJsonConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{28}
}

func (x *DotnetDepsJsonConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type DotnetPackagesConfigConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *DotnetPackagesConfigConfig) Reset() {
	*x = DotnetPackagesConfigConfig{}
	mi := &file_proto_config_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DotnetPackagesConfigConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DotnetPackagesConfigConfig) ProtoMessage() {}

func (x *DotnetPackagesConfigConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DotnetPackagesConfigConfig.ProtoReflect.Descriptor instead.
func (*DotnetPackagesConfigConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{29}
}

func (x *DotnetPackagesConfigConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type DotnetPackagesLockJsonConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *DotnetPackagesLockJsonConfig) Reset() {
	*x = DotnetPackagesLockJsonConfig{}
	mi := &file_proto_config_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DotnetPackagesLockJsonConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DotnetPackagesLockJsonConfig) ProtoMessage() {}

func (x *DotnetPackagesLockJsonConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DotnetPackagesLockJsonConfig.ProtoReflect.Descriptor instead.
func (*DotnetPackagesLockJsonConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{30}
}

func (x *DotnetPackagesLockJsonConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type DotnetPeConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *DotnetPeConfig) Reset() {
	*x = DotnetPeConfig{}
	mi := &file_proto_config_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DotnetPeConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DotnetPeConfig) ProtoMessage() {}

func (x *DotnetPeConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DotnetPeConfig.ProtoReflect.Descriptor instead.
func (*DotnetPeConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{31}
}

func (x *DotnetPeConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type GemspecConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *GemspecConfig) Reset() {
	*x = GemspecConfig{}
	mi := &file_proto_config_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GemspecConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GemspecConfig) ProtoMessage() {}

func (x *GemspecConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GemspecConfig.ProtoReflect.Descriptor instead.
func (*GemspecConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{32}
}

func (x *GemspecConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type CargoAuditableConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	// If true, extract build dependencies.
	ExtractBuildDependencies bool `protobuf:"varint,2,opt,name=extract_build_dependencies,json=extractBuildDependencies,proto3" json:"extract_build_dependencies,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *CargoAuditableConfig) Reset() {
	*x = CargoAuditableConfig{}
	mi := &file_proto_config_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CargoAuditableConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CargoAuditableConfig) ProtoMessage() {}

func (x *CargoAuditableConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CargoAuditableConfig.ProtoReflect.Descriptor instead.
func (*CargoAuditableConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{33}
}

func (x *CargoAuditableConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

func (x *CargoAuditableConfig) GetExtractBuildDependencies() bool {
	if x != nil {
		return x.ExtractBuildDependencies
	}
	return false
}

type SwiftPackageResolvedConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *SwiftPackageResolvedConfig) Reset() {
	*x = SwiftPackageResolvedConfig{}
	mi := &file_proto_config_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SwiftPackageResolvedConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SwiftPackageResolvedConfig) ProtoMessage() {}

func (x *SwiftPackageResolvedConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SwiftPackageResolvedConfig.ProtoReflect.Descriptor instead.
func (*SwiftPackageResolvedConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{34}
}

func (x *SwiftPackageResolvedConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type SwiftPodfileLockConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *SwiftPodfileLockConfig) Reset() {
	*x = SwiftPodfileLockConfig{}
	mi := &file_proto_config_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SwiftPodfileLockConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SwiftPodfileLockConfig) ProtoMessage() {}

func (x *SwiftPodfileLockConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SwiftPodfileLockConfig.ProtoReflect.Descriptor instead.
func (*SwiftPodfileLockConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{35}
}

func (x *SwiftPodfileLockConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type ElixirMixLockConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ElixirMixLockConfig) Reset() {
	*x = ElixirMixLockConfig{}
	mi := &file_proto_config_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ElixirMixLockConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ElixirMixLockConfig) ProtoMessage() {}

func (x *ElixirMixLockConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ElixirMixLockConfig.ProtoReflect.Descriptor instead.
func (*ElixirMixLockConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{36}
}

func (x *ElixirMixLockConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type HaskellStacklockConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *HaskellStacklockConfig) Reset() {
	*x = HaskellStacklockConfig{}
	mi := &file_proto_config_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HaskellStacklockConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HaskellStacklockConfig) ProtoMessage() {}

func (x *HaskellStacklockConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HaskellStacklockConfig.ProtoReflect.Descriptor instead.
func (*HaskellStacklockConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{37}
}

func (x *HaskellStacklockConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type HaskellCabalConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *HaskellCabalConfig) Reset() {
	*x = HaskellCabalConfig{}
	mi := &file_proto_config_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HaskellCabalConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HaskellCabalConfig) ProtoMessage() {}

func (x *HaskellCabalConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HaskellCabalConfig.ProtoReflect.Descriptor instead.
func (*HaskellCabalConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{38}
}

func (x *HaskellCabalConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type JavaArchiveConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	// The maximum number of inner zip files within an archive the extractor will
	// unzip.
	MaxZipDepth int32 `protobuf:"varint,2,opt,name=max_zip_depth,json=maxZipDepth,proto3" json:"max_zip_depth,omitempty"`
	// The maximum number of bytes recursively read from an archive file.
	MaxOpenedBytes int64 `protobuf:"varint,3,opt,name=max_opened_bytes,json=maxOpenedBytes,proto3" json:"max_opened_bytes,omitempty"`
	// Zip files smaller than min_zip_bytes are ignored.
	MinZipBytes int32 `protobuf:"varint,4,opt,name=min_zip_bytes,json=minZipBytes,proto3" json:"min_zip_bytes,omitempty"`
	// Configures if JAR files should be extracted from filenames when no
	// "pom.properties" is present.
	ExtractFromFilename *bool `protobuf:"varint,5,opt,name=extract_from_filename,json=extractFromFilename,proto3,oneof" json:"extract_from_filename,omitempty"`
	// Configures if JAR files should be hashed with base64(sha1()).
	HashJars      *bool `protobuf:"varint,6,opt,name=hash_jars,json=hashJars,proto3,oneof" json:"hash_jars,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *JavaArchiveConfig) Reset() {
	*x = JavaArchiveConfig{}
	mi := &file_proto_config_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JavaArchiveConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JavaArchiveConfig) ProtoMessage() {}

func (x *JavaArchiveConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JavaArchiveConfig.ProtoReflect.Descriptor instead.
func (*JavaArchiveConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{39}
}

func (x *JavaArchiveConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

func (x *JavaArchiveConfig) GetMaxZipDepth() int32 {
	if x != nil {
		return x.MaxZipDepth
	}
	return 0
}

func (x *JavaArchiveConfig) GetMaxOpenedBytes() int64 {
	if x != nil {
		return x.MaxOpenedBytes
	}
	return 0
}

func (x *JavaArchiveConfig) GetMinZipBytes() int32 {
	if x != nil {
		return x.MinZipBytes
	}
	return 0
}

func (x *JavaArchiveConfig) GetExtractFromFilename() bool {
	if x != nil && x.ExtractFromFilename != nil {
		return *x.ExtractFromFilename
	}
	return false
}

func (x *JavaArchiveConfig) GetHashJars() bool {
	if x != nil && x.HashJars != nil {
		return *x.HashJars
	}
	return false
}

type JavascriptPackageJsonConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	// Specifies whether to extract dependencies.
	IncludeDependencies bool `protobuf:"varint,2,opt,name=include_dependencies,json=includeDependencies,proto3" json:"include_dependencies,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *JavascriptPackageJsonConfig) Reset() {
	*x = JavascriptPackageJsonConfig{}
	mi := &file_proto_config_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JavascriptPackageJsonConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JavascriptPackageJsonConfig) ProtoMessage() {}

func (x *JavascriptPackageJsonConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JavascriptPackageJsonConfig.ProtoReflect.Descriptor instead.
func (*JavascriptPackageJsonConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{40}
}

func (x *JavascriptPackageJsonConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

func (x *JavascriptPackageJsonConfig) GetIncludeDependencies() bool {
	if x != nil {
		return x.IncludeDependencies
	}
	return false
}

type JavascriptPackageLockJsonConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *JavascriptPackageLockJsonConfig) Reset() {
	*x = JavascriptPackageLockJsonConfig{}
	mi := &file_proto_config_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JavascriptPackageLockJsonConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JavascriptPackageLockJsonConfig) ProtoMessage() {}

func (x *JavascriptPackageLockJsonConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JavascriptPackageLockJsonConfig.ProtoReflect.Descriptor instead.
func (*JavascriptPackageLockJsonConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{41}
}

func (x *JavascriptPackageLockJsonConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type PythonRequirementsConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *PythonRequirementsConfig) Reset() {
	*x = PythonRequirementsConfig{}
	mi := &file_proto_config_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PythonRequirementsConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PythonRequirementsConfig) ProtoMessage() {}

func (x *PythonRequirementsConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PythonRequirementsConfig.ProtoReflect.Descriptor instead.
func (*PythonRequirementsConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{42}
}

func (x *PythonRequirementsConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type PythonSetupConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *PythonSetupConfig) Reset() {
	*x = PythonSetupConfig{}
	mi := &file_proto_config_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PythonSetupConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PythonSetupConfig) ProtoMessage() {}

func (x *PythonSetupConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PythonSetupConfig.ProtoReflect.Descriptor instead.
func (*PythonSetupConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{43}
}

func (x *PythonSetupConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type PythonCondametaConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *PythonCondametaConfig) Reset() {
	*x = PythonCondametaConfig{}
	mi := &file_proto_config_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PythonCondametaConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PythonCondametaConfig) ProtoMessage() {}

func (x *PythonCondametaConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PythonCondametaConfig.ProtoReflect.Descriptor instead.
func (*PythonCondametaConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{44}
}

func (x *PythonCondametaConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type PythonWheelEggConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *PythonWheelEggConfig) Reset() {
	*x = PythonWheelEggConfig{}
	mi := &file_proto_config_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PythonWheelEggConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PythonWheelEggConfig) ProtoMessage() {}

func (x *PythonWheelEggConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PythonWheelEggConfig.ProtoReflect.Descriptor instead.
func (*PythonWheelEggConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{45}
}

func (x *PythonWheelEggConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type GoModConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Excludes indirect dependencies from the extraction.
	ExcludeIndirect bool `protobuf:"varint,1,opt,name=exclude_indirect,json=excludeIndirect,proto3" json:"exclude_indirect,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *GoModConfig) Reset() {
	*x = GoModConfig{}
	mi := &file_proto_config_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GoModConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GoModConfig) ProtoMessage() {}

func (x *GoModConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GoModConfig.ProtoReflect.Descriptor instead.
func (*GoModConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{46}
}

func (x *GoModConfig) GetExcludeIndirect() bool {
	if x != nil {
		return x.ExcludeIndirect
	}
	return false
}

type WordpressPluginsConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *WordpressPluginsConfig) Reset() {
	*x = WordpressPluginsConfig{}
	mi := &file_proto_config_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WordpressPluginsConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WordpressPluginsConfig) ProtoMessage() {}

func (x *WordpressPluginsConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WordpressPluginsConfig.ProtoReflect.Descriptor instead.
func (*WordpressPluginsConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{47}
}

func (x *WordpressPluginsConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

type MariadbConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum file size the plugin will process.
	// If set, this overrides the global max_file_size_bytes configuration
	// for this specific plugin.
	MaxFileSizeBytes int64 `protobuf:"varint,1,opt,name=max_file_size_bytes,json=maxFileSizeBytes,proto3" json:"max_file_size_bytes,omitempty"`
	// Tells the extractor to follow the include or not.
	FollowInclude *bool `protobuf:"varint,2,opt,name=follow_include,json=followInclude,proto3,oneof" json:"follow_include,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MariadbConfig) Reset() {
	*x = MariadbConfig{}
	mi := &file_proto_config_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MariadbConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MariadbConfig) ProtoMessage() {}

func (x *MariadbConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MariadbConfig.ProtoReflect.Descriptor instead.
func (*MariadbConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{48}
}

func (x *MariadbConfig) GetMaxFileSizeBytes() int64 {
	if x != nil {
		return x.MaxFileSizeBytes
	}
	return 0
}

func (x *MariadbConfig) GetFollowInclude() bool {
	if x != nil && x.FollowInclude != nil {
		return *x.FollowInclude
	}
	return false
}

type OSVLocalConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If true, OSV databases will be downloaded as needed for enriching
	Download bool `protobuf:"varint,1,opt,name=download,proto3" json:"download,omitempty"`
	// The path that the downloaded zip files should be stored at
	LocalPath string `protobuf:"bytes,2,opt,name=local_path,json=localPath,proto3" json:"local_path,omitempty"`
	// The remote host to download zip files from, which will be suffixed with
	// "/<ecosystem>/all.zip"
	RemoteHost    string `protobuf:"bytes,3,opt,name=remote_host,json=remoteHost,proto3" json:"remote_host,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OSVLocalConfig) Reset() {
	*x = OSVLocalConfig{}
	mi := &file_proto_config_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OSVLocalConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OSVLocalConfig) ProtoMessage() {}

func (x *OSVLocalConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_config_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OSVLocalConfig.ProtoReflect.Descriptor instead.
func (*OSVLocalConfig) Descriptor() ([]byte, []int) {
	return file_proto_config_proto_rawDescGZIP(), []int{49}
}

func (x *OSVLocalConfig) GetDownload() bool {
	if x != nil {
		return x.Download
	}
	return false
}

func (x *OSVLocalConfig) GetLocalPath() string {
	if x != nil {
		return x.LocalPath
	}
	return ""
}

func (x *OSVLocalConfig) GetRemoteHost() string {
	if x != nil {
		return x.RemoteHost
	}
	return ""
}

var File_proto_config_proto protoreflect.FileDescriptor

const file_proto_config_proto_rawDesc = "" +
	"\n" +
	"\x12proto/config.proto\x12\ascalibr\"\xfb\x01\n" +
	"\fPluginConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\x12%\n" +
	"\x0elocal_registry\x18\x03 \x01(\tR\rlocalRegistry\x12.\n" +
	"\x13disable_google_auth\x18\x04 \x01(\bR\x11disableGoogleAuth\x12\x1d\n" +
	"\n" +
	"user_agent\x18\x05 \x01(\tR\tuserAgent\x12F\n" +
	"\x0fplugin_specific\x18\x02 \x03(\v2\x1d.scalibr.PluginSpecificConfigR\x0epluginSpecific\"\xbb\x18\n" +
	"\x14PluginSpecificConfig\x126\n" +
	"\tgo_binary\x18\x01 \x01(\v2\x17.scalibr.GoBinaryConfigH\x00R\bgoBinary\x12>\n" +
	"\vgovulncheck\x18\x02 \x01(\v2\x1a.scalibr.GovulncheckConfigH\x00R\vgovulncheck\x122\n" +
	"\aarchive\x18\x03 \x01(\v2\x16.scalibr.ArchiveConfigH\x00R\aarchive\x12&\n" +
	"\x03ova\x18\x04 \x01(\v2\x12.scalibr.OVAConfigH\x00R\x03ova\x12&\n" +
	"\x03vdi\x18\x05 \x01(\v2\x12.scalibr.VDIConfigH\x00R\x03vdi\x12)\n" +
	"\x04vmdk\x18\x06 \x01(\v2\x13.scalibr.VMDKConfigH\x00R\x04vmdk\x12d\n" +
	"\x19hashicorp_vault_validator\x18\a \x01(\v2&.scalibr.HashiCorpVaultValidatorConfigH\x00R\x17hashicorpVaultValidator\x12<\n" +
	"\vsdp_inspect\x18\b \x01(\v2\x19.scalibr.SDPInspectConfigH\x00R\n" +
	"sdpInspect\x12:\n" +
	"\vpom_xml_net\x18\t \x01(\v2\x18.scalibr.POMXMLNetConfigH\x00R\tpomXmlNet\x12;\n" +
	"\n" +
	"chocolatey\x18\n" +
	" \x01(\v2\x19.scalibr.ChocolateyConfigH\x00R\n" +
	"chocolatey\x12)\n" +
	"\x04dpkg\x18\v \x01(\v2\x13.scalibr.DpkgConfigH\x00R\x04dpkg\x12&\n" +
	"\x03rpm\x18\f \x01(\v2\x12.scalibr.RpmConfigH\x00R\x03rpm\x12&\n" +
	"\x03apk\x18\r \x01(\v2\x12.scalibr.ApkConfigH\x00R\x03apk\x12&\n" +
	"\x03cos\x18\x0e \x01(\v2\x12.scalibr.CosConfigH\x00R\x03cos\x12)\n" +
	"\x04snap\x18\x0f \x01(\v2\x13.scalibr.SnapConfigH\x00R\x04snap\x12B\n" +
	"\rkernel_module\x18\x10 \x01(\v2\x1b.scalibr.KernelModuleConfigH\x00R\fkernelModule\x122\n" +
	"\avmlinuz\x18\x11 \x01(\v2\x16.scalibr.VmlinuzConfigH\x00R\avmlinuz\x12/\n" +
	"\x06pacman\x18\x12 \x01(\v2\x15.scalibr.PacmanConfigH\x00R\x06pacman\x122\n" +
	"\aportage\x18\x13 \x01(\v2\x16.scalibr.PortageConfigH\x00R\aportage\x122\n" +
	"\aflatpak\x18\x14 \x01(\v2\x16.scalibr.FlatpakConfigH\x00R\aflatpak\x122\n" +
	"\amacapps\x18\x15 \x01(\v2\x16.scalibr.MacAppsConfigH\x00R\amacapps\x12/\n" +
	"\x06podman\x18\x16 \x01(\v2\x15.scalibr.PodmanConfigH\x00R\x06podman\x12L\n" +
	"\x11docker_base_image\x18\x17 \x01(\v2\x1e.scalibr.DockerBaseImageConfigH\x00R\x0fdockerBaseImage\x12;\n" +
	"\n" +
	"containerd\x18\x18 \x01(\v2\x19.scalibr.ContainerdConfigH\x00R\n" +
	"containerd\x12U\n" +
	"\x14docker_compose_image\x18\x19 \x01(\v2!.scalibr.DockerComposeImageConfigH\x00R\x12dockerComposeImage\x126\n" +
	"\tk8s_image\x18\x1a \x01(\v2\x17.scalibr.K8sImageConfigH\x00R\bk8sImage\x12I\n" +
	"\x10dotnet_deps_json\x18\x1b \x01(\v2\x1d.scalibr.DotnetDepsJsonConfigH\x00R\x0edotnetDepsJson\x12[\n" +
	"\x16dotnet_packages_config\x18\x1c \x01(\v2#.scalibr.DotnetPackagesConfigConfigH\x00R\x14dotnetPackagesConfig\x12b\n" +
	"\x19dotnet_packages_lock_json\x18\x1d \x01(\v2%.scalibr.DotnetPackagesLockJsonConfigH\x00R\x16dotnetPackagesLockJson\x126\n" +
	"\tdotnet_pe\x18\x1e \x01(\v2\x17.scalibr.DotnetPeConfigH\x00R\bdotnetPe\x122\n" +
	"\agemspec\x18\x1f \x01(\v2\x16.scalibr.GemspecConfigH\x00R\agemspec\x12H\n" +
	"\x0fcargo_auditable\x18  \x01(\v2\x1d.scalibr.CargoAuditableConfigH\x00R\x0ecargoAuditable\x12[\n" +
	"\x16swift_package_resolved\x18! \x01(\v2#.scalibr.SwiftPackageResolvedConfigH\x00R\x14swiftPackageResolved\x12O\n" +
	"\x12swift_podfile_lock\x18\" \x01(\v2\x1f.scalibr.SwiftPodfileLockConfigH\x00R\x10swiftPodfileLock\x12F\n" +
	"\x0felixir_mix_lock\x18# \x01(\v2\x1c.scalibr.ElixirMixLockConfigH\x00R\relixirMixLock\x12N\n" +
	"\x11haskell_stacklock\x18$ \x01(\v2\x1f.scalibr.HaskellStacklockConfigH\x00R\x10haskellStacklock\x12B\n" +
	"\rhaskell_cabal\x18% \x01(\v2\x1b.scalibr.HaskellCabalConfigH\x00R\fhaskellCabal\x12?\n" +
	"\fjava_archive\x18& \x01(\v2\x1a.scalibr.JavaArchiveConfigH\x00R\vjavaArchive\x12^\n" +
	"\x17javascript_package_json\x18' \x01(\v2$.scalibr.JavascriptPackageJsonConfigH\x00R\x15javascriptPackageJson\x12k\n" +
	"\x1cjavascript_package_lock_json\x18( \x01(\v2(.scalibr.JavascriptPackageLockJsonConfigH\x00R\x19javascriptPackageLockJson\x12T\n" +
	"\x13python_requirements\x18) \x01(\v2!.scalibr.PythonRequirementsConfigH\x00R\x12pythonRequirements\x12?\n" +
	"\fpython_setup\x18* \x01(\v2\x1a.scalibr.PythonSetupConfigH\x00R\vpythonSetup\x12K\n" +
	"\x10python_condameta\x18+ \x01(\v2\x1e.scalibr.PythonCondametaConfigH\x00R\x0fpythonCondameta\x12I\n" +
	"\x10python_wheel_egg\x18, \x01(\v2\x1d.scalibr.PythonWheelEggConfigH\x00R\x0epythonWheelEgg\x12-\n" +
	"\x06go_mod\x18- \x01(\v2\x14.scalibr.GoModConfigH\x00R\x05goMod\x12N\n" +
	"\x11wordpress_plugins\x18. \x01(\v2\x1f.scalibr.WordpressPluginsConfigH\x00R\x10wordpressPlugins\x122\n" +
	"\amariadb\x18/ \x01(\v2\x16.scalibr.MariadbConfigH\x00R\amariadb\x125\n" +
	"\bosvlocal\x189 \x01(\v2\x17.scalibr.OSVLocalConfigH\x00R\bosvlocalB\b\n" +
	"\x06configJ\x04\b0\x109\"B\n" +
	"\x0eGoBinaryConfig\x120\n" +
	"\x14version_from_content\x18\x01 \x01(\bR\x12versionFromContent\"D\n" +
	"\x11GovulncheckConfig\x12/\n" +
	"\x14offline_vuln_db_path\x18\x01 \x01(\tR\x11offlineVulnDbPath\">\n" +
	"\rArchiveConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\":\n" +
	"\tOVAConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\":\n" +
	"\tVDIConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\";\n" +
	"\n" +
	"VMDKConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"A\n" +
	"\x10ChocolateyConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"<\n" +
	"\x1dHashiCorpVaultValidatorConfig\x12\x1b\n" +
	"\tvault_url\x18\x01 \x01(\tR\bvaultUrl\"1\n" +
	"\x10SDPInspectConfig\x12\x1d\n" +
	"\n" +
	"project_id\x18\x01 \x01(\tR\tprojectId\"r\n" +
	"\x0fPOMXMLNetConfig\x12+\n" +
	"\x11upstream_registry\x18\x01 \x01(\tR\x10upstreamRegistry\x122\n" +
	"\x15deps_dev_requirements\x18\x02 \x01(\bR\x13depsDevRequirements\"o\n" +
	"\n" +
	"DpkgConfig\x122\n" +
	"\x15include_not_installed\x18\x01 \x01(\bR\x13includeNotInstalled\x12-\n" +
	"\x13max_file_size_bytes\x18\x02 \x01(\x03R\x10maxFileSizeBytes\"c\n" +
	"\tRpmConfig\x12'\n" +
	"\x0ftimeout_seconds\x18\x01 \x01(\x03R\x0etimeoutSeconds\x12-\n" +
	"\x13max_file_size_bytes\x18\x02 \x01(\x03R\x10maxFileSizeBytes\":\n" +
	"\tApkConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\":\n" +
	"\tCosConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\";\n" +
	"\n" +
	"SnapConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"C\n" +
	"\x12KernelModuleConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\">\n" +
	"\rVmlinuzConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"=\n" +
	"\fPacmanConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\">\n" +
	"\rPortageConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\">\n" +
	"\rFlatpakConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\">\n" +
	"\rMacAppsConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"7\n" +
	"\fPodmanConfig\x12'\n" +
	"\x0finclude_stopped\x18\x01 \x01(\bR\x0eincludeStopped\"F\n" +
	"\x15DockerBaseImageConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"A\n" +
	"\x10ContainerdConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"I\n" +
	"\x18DockerComposeImageConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"?\n" +
	"\x0eK8sImageConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"E\n" +
	"\x14DotnetDepsJsonConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"K\n" +
	"\x1aDotnetPackagesConfigConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"M\n" +
	"\x1cDotnetPackagesLockJsonConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"?\n" +
	"\x0eDotnetPeConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\">\n" +
	"\rGemspecConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"\x83\x01\n" +
	"\x14CargoAuditableConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\x12<\n" +
	"\x1aextract_build_dependencies\x18\x02 \x01(\bR\x18extractBuildDependencies\"K\n" +
	"\x1aSwiftPackageResolvedConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"G\n" +
	"\x16SwiftPodfileLockConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"D\n" +
	"\x13ElixirMixLockConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"G\n" +
	"\x16HaskellStacklockConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"C\n" +
	"\x12HaskellCabalConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"\xb7\x02\n" +
	"\x11JavaArchiveConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\x12\"\n" +
	"\rmax_zip_depth\x18\x02 \x01(\x05R\vmaxZipDepth\x12(\n" +
	"\x10max_opened_bytes\x18\x03 \x01(\x03R\x0emaxOpenedBytes\x12\"\n" +
	"\rmin_zip_bytes\x18\x04 \x01(\x05R\vminZipBytes\x127\n" +
	"\x15extract_from_filename\x18\x05 \x01(\bH\x00R\x13extractFromFilename\x88\x01\x01\x12 \n" +
	"\thash_jars\x18\x06 \x01(\bH\x01R\bhashJars\x88\x01\x01B\x18\n" +
	"\x16_extract_from_filenameB\f\n" +
	"\n" +
	"_hash_jars\"\x7f\n" +
	"\x1bJavascriptPackageJsonConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\x121\n" +
	"\x14include_dependencies\x18\x02 \x01(\bR\x13includeDependencies\"P\n" +
	"\x1fJavascriptPackageLockJsonConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"I\n" +
	"\x18PythonRequirementsConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"B\n" +
	"\x11PythonSetupConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"F\n" +
	"\x15PythonCondametaConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"E\n" +
	"\x14PythonWheelEggConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"8\n" +
	"\vGoModConfig\x12)\n" +
	"\x10exclude_indirect\x18\x01 \x01(\bR\x0fexcludeIndirect\"G\n" +
	"\x16WordpressPluginsConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\"}\n" +
	"\rMariadbConfig\x12-\n" +
	"\x13max_file_size_bytes\x18\x01 \x01(\x03R\x10maxFileSizeBytes\x12*\n" +
	"\x0efollow_include\x18\x02 \x01(\bH\x00R\rfollowInclude\x88\x01\x01B\x11\n" +
	"\x0f_follow_include\"l\n" +
	"\x0eOSVLocalConfig\x12\x1a\n" +
	"\bdownload\x18\x01 \x01(\bR\bdownload\x12\x1d\n" +
	"\n" +
	"local_path\x18\x02 \x01(\tR\tlocalPath\x12\x1f\n" +
	"\vremote_host\x18\x03 \x01(\tR\n" +
	"remoteHostBFB\x06ConfigP\x01Z:github.com/google/osv-scalibr/binary/proto/config_go_protob\x06proto3"

var (
	file_proto_config_proto_rawDescOnce sync.Once
	file_proto_config_proto_rawDescData []byte
)

func file_proto_config_proto_rawDescGZIP() []byte {
	file_proto_config_proto_rawDescOnce.Do(func() {
		file_proto_config_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_config_proto_rawDesc), len(file_proto_config_proto_rawDesc)))
	})
	return file_proto_config_proto_rawDescData
}

var file_proto_config_proto_msgTypes = make([]protoimpl.MessageInfo, 50)
var file_proto_config_proto_goTypes = []any{
	(*PluginConfig)(nil),                    // 0: scalibr.PluginConfig
	(*PluginSpecificConfig)(nil),            // 1: scalibr.PluginSpecificConfig
	(*GoBinaryConfig)(nil),                  // 2: scalibr.GoBinaryConfig
	(*GovulncheckConfig)(nil),               // 3: scalibr.GovulncheckConfig
	(*ArchiveConfig)(nil),                   // 4: scalibr.ArchiveConfig
	(*OVAConfig)(nil),                       // 5: scalibr.OVAConfig
	(*VDIConfig)(nil),                       // 6: scalibr.VDIConfig
	(*VMDKConfig)(nil),                      // 7: scalibr.VMDKConfig
	(*ChocolateyConfig)(nil),                // 8: scalibr.ChocolateyConfig
	(*HashiCorpVaultValidatorConfig)(nil),   // 9: scalibr.HashiCorpVaultValidatorConfig
	(*SDPInspectConfig)(nil),                // 10: scalibr.SDPInspectConfig
	(*POMXMLNetConfig)(nil),                 // 11: scalibr.POMXMLNetConfig
	(*DpkgConfig)(nil),                      // 12: scalibr.DpkgConfig
	(*RpmConfig)(nil),                       // 13: scalibr.RpmConfig
	(*ApkConfig)(nil),                       // 14: scalibr.ApkConfig
	(*CosConfig)(nil),                       // 15: scalibr.CosConfig
	(*SnapConfig)(nil),                      // 16: scalibr.SnapConfig
	(*KernelModuleConfig)(nil),              // 17: scalibr.KernelModuleConfig
	(*VmlinuzConfig)(nil),                   // 18: scalibr.VmlinuzConfig
	(*PacmanConfig)(nil),                    // 19: scalibr.PacmanConfig
	(*PortageConfig)(nil),                   // 20: scalibr.PortageConfig
	(*FlatpakConfig)(nil),                   // 21: scalibr.FlatpakConfig
	(*MacAppsConfig)(nil),                   // 22: scalibr.MacAppsConfig
	(*PodmanConfig)(nil),                    // 23: scalibr.PodmanConfig
	(*DockerBaseImageConfig)(nil),           // 24: scalibr.DockerBaseImageConfig
	(*ContainerdConfig)(nil),                // 25: scalibr.ContainerdConfig
	(*DockerComposeImageConfig)(nil),        // 26: scalibr.DockerComposeImageConfig
	(*K8SImageConfig)(nil),                  // 27: scalibr.K8sImageConfig
	(*DotnetDepsJsonConfig)(nil),            // 28: scalibr.DotnetDepsJsonConfig
	(*DotnetPackagesConfigConfig)(nil),      // 29: scalibr.DotnetPackagesConfigConfig
	(*DotnetPackagesLockJsonConfig)(nil),    // 30: scalibr.DotnetPackagesLockJsonConfig
	(*DotnetPeConfig)(nil),                  // 31: scalibr.DotnetPeConfig
	(*GemspecConfig)(nil),                   // 32: scalibr.GemspecConfig
	(*CargoAuditableConfig)(nil),            // 33: scalibr.CargoAuditableConfig
	(*SwiftPackageResolvedConfig)(nil),      // 34: scalibr.SwiftPackageResolvedConfig
	(*SwiftPodfileLockConfig)(nil),          // 35: scalibr.SwiftPodfileLockConfig
	(*ElixirMixLockConfig)(nil),             // 36: scalibr.ElixirMixLockConfig
	(*HaskellStacklockConfig)(nil),          // 37: scalibr.HaskellStacklockConfig
	(*HaskellCabalConfig)(nil),              // 38: scalibr.HaskellCabalConfig
	(*JavaArchiveConfig)(nil),               // 39: scalibr.JavaArchiveConfig
	(*JavascriptPackageJsonConfig)(nil),     // 40: scalibr.JavascriptPackageJsonConfig
	(*JavascriptPackageLockJsonConfig)(nil), // 41: scalibr.JavascriptPackageLockJsonConfig
	(*PythonRequirementsConfig)(nil),        // 42: scalibr.PythonRequirementsConfig
	(*PythonSetupConfig)(nil),               // 43: scalibr.PythonSetupConfig
	(*PythonCondametaConfig)(nil),           // 44: scalibr.PythonCondametaConfig
	(*PythonWheelEggConfig)(nil),            // 45: scalibr.PythonWheelEggConfig
	(*GoModConfig)(nil),                     // 46: scalibr.GoModConfig
	(*WordpressPluginsConfig)(nil),          // 47: scalibr.WordpressPluginsConfig
	(*MariadbConfig)(nil),                   // 48: scalibr.MariadbConfig
	(*OSVLocalConfig)(nil),                  // 49: scalibr.OSVLocalConfig
}
var file_proto_config_proto_depIdxs = []int32{
	1,  // 0: scalibr.PluginConfig.plugin_specific:type_name -> scalibr.PluginSpecificConfig
	2,  // 1: scalibr.PluginSpecificConfig.go_binary:type_name -> scalibr.GoBinaryConfig
	3,  // 2: scalibr.PluginSpecificConfig.govulncheck:type_name -> scalibr.GovulncheckConfig
	4,  // 3: scalibr.PluginSpecificConfig.archive:type_name -> scalibr.ArchiveConfig
	5,  // 4: scalibr.PluginSpecificConfig.ova:type_name -> scalibr.OVAConfig
	6,  // 5: scalibr.PluginSpecificConfig.vdi:type_name -> scalibr.VDIConfig
	7,  // 6: scalibr.PluginSpecificConfig.vmdk:type_name -> scalibr.VMDKConfig
	9,  // 7: scalibr.PluginSpecificConfig.hashicorp_vault_validator:type_name -> scalibr.HashiCorpVaultValidatorConfig
	10, // 8: scalibr.PluginSpecificConfig.sdp_inspect:type_name -> scalibr.SDPInspectConfig
	11, // 9: scalibr.PluginSpecificConfig.pom_xml_net:type_name -> scalibr.POMXMLNetConfig
	8,  // 10: scalibr.PluginSpecificConfig.chocolatey:type_name -> scalibr.ChocolateyConfig
	12, // 11: scalibr.PluginSpecificConfig.dpkg:type_name -> scalibr.DpkgConfig
	13, // 12: scalibr.PluginSpecificConfig.rpm:type_name -> scalibr.RpmConfig
	14, // 13: scalibr.PluginSpecificConfig.apk:type_name -> scalibr.ApkConfig
	15, // 14: scalibr.PluginSpecificConfig.cos:type_name -> scalibr.CosConfig
	16, // 15: scalibr.PluginSpecificConfig.snap:type_name -> scalibr.SnapConfig
	17, // 16: scalibr.PluginSpecificConfig.kernel_module:type_name -> scalibr.KernelModuleConfig
	18, // 17: scalibr.PluginSpecificConfig.vmlinuz:type_name -> scalibr.VmlinuzConfig
	19, // 18: scalibr.PluginSpecificConfig.pacman:type_name -> scalibr.PacmanConfig
	20, // 19: scalibr.PluginSpecificConfig.portage:type_name -> scalibr.PortageConfig
	21, // 20: scalibr.PluginSpecificConfig.flatpak:type_name -> scalibr.FlatpakConfig
	22, // 21: scalibr.PluginSpecificConfig.macapps:type_name -> scalibr.MacAppsConfig
	23, // 22: scalibr.PluginSpecificConfig.podman:type_name -> scalibr.PodmanConfig
	24, // 23: scalibr.PluginSpecificConfig.docker_base_image:type_name -> scalibr.DockerBaseImageConfig
	25, // 24: scalibr.PluginSpecificConfig.containerd:type_name -> scalibr.ContainerdConfig
	26, // 25: scalibr.PluginSpecificConfig.docker_compose_image:type_name -> scalibr.DockerComposeImageConfig
	27, // 26: scalibr.PluginSpecificConfig.k8s_image:type_name -> scalibr.K8sImageConfig
	28, // 27: scalibr.PluginSpecificConfig.dotnet_deps_json:type_name -> scalibr.DotnetDepsJsonConfig
	29, // 28: scalibr.PluginSpecificConfig.dotnet_packages_config:type_name -> scalibr.DotnetPackagesConfigConfig
	30, // 29: scalibr.PluginSpecificConfig.dotnet_packages_lock_json:type_name -> scalibr.DotnetPackagesLockJsonConfig
	31, // 30: scalibr.PluginSpecificConfig.dotnet_pe:type_name -> scalibr.DotnetPeConfig
	32, // 31: scalibr.PluginSpecificConfig.gemspec:type_name -> scalibr.GemspecConfig
	33, // 32: scalibr.PluginSpecificConfig.cargo_auditable:type_name -> scalibr.CargoAuditableConfig
	34, // 33: scalibr.PluginSpecificConfig.swift_package_resolved:type_name -> scalibr.SwiftPackageResolvedConfig
	35, // 34: scalibr.PluginSpecificConfig.swift_podfile_lock:type_name -> scalibr.SwiftPodfileLockConfig
	36, // 35: scalibr.PluginSpecificConfig.elixir_mix_lock:type_name -> scalibr.ElixirMixLockConfig
	37, // 36: scalibr.PluginSpecificConfig.haskell_stacklock:type_name -> scalibr.HaskellStacklockConfig
	38, // 37: scalibr.PluginSpecificConfig.haskell_cabal:type_name -> scalibr.HaskellCabalConfig
	39, // 38: scalibr.PluginSpecificConfig.java_archive:type_name -> scalibr.JavaArchiveConfig
	40, // 39: scalibr.PluginSpecificConfig.javascript_package_json:type_name -> scalibr.JavascriptPackageJsonConfig
	41, // 40: scalibr.PluginSpecificConfig.javascript_package_lock_json:type_name -> scalibr.JavascriptPackageLockJsonConfig
	42, // 41: scalibr.PluginSpecificConfig.python_requirements:type_name -> scalibr.PythonRequirementsConfig
	43, // 42: scalibr.PluginSpecificConfig.python_setup:type_name -> scalibr.PythonSetupConfig
	44, // 43: scalibr.PluginSpecificConfig.python_condameta:type_name -> scalibr.PythonCondametaConfig
	45, // 44: scalibr.PluginSpecificConfig.python_wheel_egg:type_name -> scalibr.PythonWheelEggConfig
	46, // 45: scalibr.PluginSpecificConfig.go_mod:type_name -> scalibr.GoModConfig
	47, // 46: scalibr.PluginSpecificConfig.wordpress_plugins:type_name -> scalibr.WordpressPluginsConfig
	48, // 47: scalibr.PluginSpecificConfig.mariadb:type_name -> scalibr.MariadbConfig
	49, // 48: scalibr.PluginSpecificConfig.osvlocal:type_name -> scalibr.OSVLocalConfig
	49, // [49:49] is the sub-list for method output_type
	49, // [49:49] is the sub-list for method input_type
	49, // [49:49] is the sub-list for extension type_name
	49, // [49:49] is the sub-list for extension extendee
	0,  // [0:49] is the sub-list for field type_name
}

func init() { file_proto_config_proto_init() }
func file_proto_config_proto_init() {
	if File_proto_config_proto != nil {
		return
	}
	file_proto_config_proto_msgTypes[1].OneofWrappers = []any{
		(*PluginSpecificConfig_GoBinary)(nil),
		(*PluginSpecificConfig_Govulncheck)(nil),
		(*PluginSpecificConfig_Archive)(nil),
		(*PluginSpecificConfig_Ova)(nil),
		(*PluginSpecificConfig_Vdi)(nil),
		(*PluginSpecificConfig_Vmdk)(nil),
		(*PluginSpecificConfig_HashicorpVaultValidator)(nil),
		(*PluginSpecificConfig_SdpInspect)(nil),
		(*PluginSpecificConfig_PomXmlNet)(nil),
		(*PluginSpecificConfig_Chocolatey)(nil),
		(*PluginSpecificConfig_Dpkg)(nil),
		(*PluginSpecificConfig_Rpm)(nil),
		(*PluginSpecificConfig_Apk)(nil),
		(*PluginSpecificConfig_Cos)(nil),
		(*PluginSpecificConfig_Snap)(nil),
		(*PluginSpecificConfig_KernelModule)(nil),
		(*PluginSpecificConfig_Vmlinuz)(nil),
		(*PluginSpecificConfig_Pacman)(nil),
		(*PluginSpecificConfig_Portage)(nil),
		(*PluginSpecificConfig_Flatpak)(nil),
		(*PluginSpecificConfig_Macapps)(nil),
		(*PluginSpecificConfig_Podman)(nil),
		(*PluginSpecificConfig_DockerBaseImage)(nil),
		(*PluginSpecificConfig_Containerd)(nil),
		(*PluginSpecificConfig_DockerComposeImage)(nil),
		(*PluginSpecificConfig_K8SImage)(nil),
		(*PluginSpecificConfig_DotnetDepsJson)(nil),
		(*PluginSpecificConfig_DotnetPackagesConfig)(nil),
		(*PluginSpecificConfig_DotnetPackagesLockJson)(nil),
		(*PluginSpecificConfig_DotnetPe)(nil),
		(*PluginSpecificConfig_Gemspec)(nil),
		(*PluginSpecificConfig_CargoAuditable)(nil),
		(*PluginSpecificConfig_SwiftPackageResolved)(nil),
		(*PluginSpecificConfig_SwiftPodfileLock)(nil),
		(*PluginSpecificConfig_ElixirMixLock)(nil),
		(*PluginSpecificConfig_HaskellStacklock)(nil),
		(*PluginSpecificConfig_HaskellCabal)(nil),
		(*PluginSpecificConfig_JavaArchive)(nil),
		(*PluginSpecificConfig_JavascriptPackageJson)(nil),
		(*PluginSpecificConfig_JavascriptPackageLockJson)(nil),
		(*PluginSpecificConfig_PythonRequirements)(nil),
		(*PluginSpecificConfig_PythonSetup)(nil),
		(*PluginSpecificConfig_PythonCondameta)(nil),
		(*PluginSpecificConfig_PythonWheelEgg)(nil),
		(*PluginSpecificConfig_GoMod)(nil),
		(*PluginSpecificConfig_WordpressPlugins)(nil),
		(*PluginSpecificConfig_Mariadb)(nil),
		(*PluginSpecificConfig_Osvlocal)(nil),
	}
	file_proto_config_proto_msgTypes[39].OneofWrappers = []any{}
	file_proto_config_proto_msgTypes[48].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_config_proto_rawDesc), len(file_proto_config_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   50,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_config_proto_goTypes,
		DependencyIndexes: file_proto_config_proto_depIdxs,
		MessageInfos:      file_proto_config_proto_msgTypes,
	}.Build()
	File_proto_config_proto = out.File
	file_proto_config_proto_goTypes = nil
	file_proto_config_proto_depIdxs = nil
}
