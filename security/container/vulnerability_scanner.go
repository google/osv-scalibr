// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package container provides advanced container security scanning capabilities.
package container

import (
	"context"
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"regexp"
	"strings"
	"sync"
	"time"

	"github.com/google/osv-scalibr/extractor"
	"github.com/google/osv-scalibr/inventory"
	"github.com/google/osv-scalibr/log"
)

// VulnerabilityScanner provides advanced container vulnerability scanning.
type VulnerabilityScanner struct {
	config          Config
	vulnerabilityDB map[string]*VulnerabilityInfo
	cache           sync.Map
	mutex           sync.RWMutex
}

// Config configures the container vulnerability scanner.
type Config struct {
	EnableLayerAnalysis    bool
	EnableSecretScanning   bool
	EnableMalwareDetection bool
	EnableComplianceCheck  bool
	MaxConcurrentScans     int
	VulnerabilityDBPath    string
	CustomRules            []*SecurityRule
}

// VulnerabilityInfo contains information about a specific vulnerability.
type VulnerabilityInfo struct {
	ID          string    `json:"id"`
	Title       string    `json:"title"`
	Description string    `json:"description"`
	Severity    string    `json:"severity"`
	CVSS        float64   `json:"cvss"`
	Published   time.Time `json:"published"`
	Modified    time.Time `json:"modified"`
	References  []string  `json:"references"`
	Affected    []string  `json:"affected_packages"`
}

// SecurityRule defines a custom security rule for container scanning.
type SecurityRule struct {
	ID          string
	Name        string
	Description string
	Category    string
	Severity    string
	Pattern     *regexp.Regexp
	FileTypes   []string
	Checker     func(content, path string) []ContainerFinding
}

// ContainerFinding represents a security finding in a container.
type ContainerFinding struct {
	ID           string                 `json:"id"`
	Type         string                 `json:"type"`
	Severity     string                 `json:"severity"`
	Title        string                 `json:"title"`
	Description  string                 `json:"description"`
	Layer        string                 `json:"layer,omitempty"`
	File         string                 `json:"file,omitempty"`
	Evidence     string                 `json:"evidence,omitempty"`
	Remediation  string                 `json:"remediation,omitempty"`
	References   []string               `json:"references,omitempty"`
	Metadata     map[string]interface{} `json:"metadata,omitempty"`
}

// LayerAnalysis contains analysis results for a container layer.
type LayerAnalysis struct {
	LayerID     string             `json:"layer_id"`
	Size        int64              `json:"size"`
	Command     string             `json:"command,omitempty"`
	Packages    []*extractor.Package `json:"packages"`
	Findings    []ContainerFinding `json:"findings"`
	Secrets     []SecretFinding    `json:"secrets"`
	Malware     []MalwareFinding   `json:"malware"`
	Compliance  []ComplianceFinding `json:"compliance"`
}

// SecretFinding represents a detected secret in the container.
type SecretFinding struct {
	Type        string `json:"type"`
	File        string `json:"file"`
	LineNumber  int    `json:"line_number"`
	Pattern     string `json:"pattern"`
	Confidence  float64 `json:"confidence"`
	Masked      string `json:"masked_value"`
}

// MalwareFinding represents detected malware in the container.
type MalwareFinding struct {
	Type        string  `json:"type"`
	File        string  `json:"file"`
	Signature   string  `json:"signature"`
	Confidence  float64 `json:"confidence"`
	Description string  `json:"description"`
}

// ComplianceFinding represents a compliance violation.
type ComplianceFinding struct {
	Standard    string `json:"standard"`
	Rule        string `json:"rule"`
	Severity    string `json:"severity"`
	Description string `json:"description"`
	File        string `json:"file,omitempty"`
	Remediation string `json:"remediation"`
}

// New creates a new container vulnerability scanner.
func New(cfg Config) *VulnerabilityScanner {
	scanner := &VulnerabilityScanner{
		config:          cfg,
		vulnerabilityDB: make(map[string]*VulnerabilityInfo),
	}
	
	scanner.initializeBuiltinRules()
	scanner.loadVulnerabilityDatabase()
	
	return scanner
}

// ScanContainer performs comprehensive security scanning of a container.
func (vs *VulnerabilityScanner) ScanContainer(ctx context.Context, layers []LayerInfo) (*ContainerScanResult, error) {
	result := &ContainerScanResult{
		ScanID:    generateScanID(),
		Timestamp: time.Now(),
		Layers:    make([]LayerAnalysis, 0, len(layers)),
	}
	
	// Scan each layer
	for _, layer := range layers {
		analysis, err := vs.scanLayer(ctx, layer)
		if err != nil {
			log.Errorf("Failed to scan layer %s: %v", layer.ID, err)
			continue
		}
		result.Layers = append(result.Layers, *analysis)
	}
	
	// Aggregate findings
	result.Summary = vs.aggregateFindings(result.Layers)
	
	return result, nil
}

// scanLayer performs detailed analysis of a single container layer.
func (vs *VulnerabilityScanner) scanLayer(ctx context.Context, layer LayerInfo) (*LayerAnalysis, error) {
	analysis := &LayerAnalysis{
		LayerID: layer.ID,
		Size:    layer.Size,
		Command: layer.Command,
	}
	
	// Package vulnerability scanning
	for _, pkg := range layer.Packages {
		findings := vs.scanPackageVulnerabilities(pkg)
		analysis.Findings = append(analysis.Findings, findings...)
	}
	
	// Secret scanning
	if vs.config.EnableSecretScanning {
		secrets := vs.scanSecrets(layer.Files)
		analysis.Secrets = secrets
	}
	
	// Malware detection
	if vs.config.EnableMalwareDetection {
		malware := vs.scanMalware(layer.Files)
		analysis.Malware = malware
	}
	
	// Compliance checking
	if vs.config.EnableComplianceCheck {
		compliance := vs.scanCompliance(layer)
		analysis.Compliance = compliance
	}
	
	return analysis, nil
}

// scanPackageVulnerabilities scans packages for known vulnerabilities.
func (vs *VulnerabilityScanner) scanPackageVulnerabilities(pkg *extractor.Package) []ContainerFinding {
	var findings []ContainerFinding
	
	vs.mutex.RLock()
	defer vs.mutex.RUnlock()
	
	// Check against vulnerability database
	for vulnID, vuln := range vs.vulnerabilityDB {
		if vs.packageMatchesVulnerability(pkg, vuln) {
			finding := ContainerFinding{
				ID:          vulnID,
				Type:        "vulnerability",
				Severity:    vuln.Severity,
				Title:       vuln.Title,
				Description: vuln.Description,
				Evidence:    fmt.Sprintf("Package: %s@%s", pkg.Name, pkg.Version),
				Remediation: vs.getVulnerabilityRemediation(vulnID),
				References:  vuln.References,
				Metadata: map[string]interface{}{
					"cvss":      vuln.CVSS,
					"published": vuln.Published,
					"package":   pkg.Name,
					"version":   pkg.Version,
				},
			}
			findings = append(findings, finding)
		}
	}
	
	return findings
}

// scanSecrets scans files for hardcoded secrets and credentials.
func (vs *VulnerabilityScanner) scanSecrets(files []FileInfo) []SecretFinding {
	var secrets []SecretFinding
	
	secretPatterns := map[string]*regexp.Regexp{
		"aws_access_key":    regexp.MustCompile(`AKIA[0-9A-Z]{16}`),
		"aws_secret_key":    regexp.MustCompile(`[0-9a-zA-Z/+]{40}`),
		"github_token":      regexp.MustCompile(`ghp_[0-9a-zA-Z]{36}`),
		"slack_token":       regexp.MustCompile(`xox[baprs]-[0-9a-zA-Z-]{10,48}`),
		"private_key":       regexp.MustCompile(`-----BEGIN (RSA |EC |DSA )?PRIVATE KEY-----`),
		"jwt_token":         regexp.MustCompile(`eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*`),
		"database_url":      regexp.MustCompile(`(mysql|postgres|mongodb)://[^\s]+`),
		"api_key":           regexp.MustCompile(`(?i)api[_-]?key['":\s]*[=:]\s*['"][0-9a-zA-Z]{20,}['"]`),
		"password":          regexp.MustCompile(`(?i)password['":\s]*[=:]\s*['"][^'"]{8,}['"]`),
	}
	
	for _, file := range files {
		if vs.shouldSkipSecretScan(file.Path) {
			continue
		}
		
		lines := strings.Split(file.Content, "\n")
		for lineNum, line := range lines {
			for secretType, pattern := range secretPatterns {
				if matches := pattern.FindAllString(line, -1); len(matches) > 0 {
					for _, match := range matches {
						secret := SecretFinding{
							Type:       secretType,
							File:       file.Path,
							LineNumber: lineNum + 1,
							Pattern:    pattern.String(),
							Confidence: vs.calculateSecretConfidence(secretType, match),
							Masked:     vs.maskSecret(match),
						}
						secrets = append(secrets, secret)
					}
				}
			}
		}
	}
	
	return secrets
}

// scanMalware performs basic malware detection using signatures.
func (vs *VulnerabilityScanner) scanMalware(files []FileInfo) []MalwareFinding {
	var malware []MalwareFinding
	
	// Basic malware signatures
	malwareSignatures := map[string]*regexp.Regexp{
		"suspicious_shell":     regexp.MustCompile(`(?i)(wget|curl).*\|\s*(sh|bash|python)`),
		"reverse_shell":        regexp.MustCompile(`(?i)(nc|netcat).*-e\s*(sh|bash)`),
		"crypto_miner":         regexp.MustCompile(`(?i)(xmrig|cpuminer|cgminer|bfgminer)`),
		"backdoor_pattern":     regexp.MustCompile(`(?i)(backdoor|rootkit|trojan)`),
		"suspicious_download":  regexp.MustCompile(`(?i)(wget|curl).*\.(sh|py|pl|exe|bin).*chmod\s*\+x`),
		"data_exfiltration":    regexp.MustCompile(`(?i)(curl|wget).*-X\s*POST.*--data`),
	}
	
	for _, file := range files {
		if vs.shouldSkipMalwareScan(file.Path) {
			continue
		}
		
		for malwareType, signature := range malwareSignatures {
			if signature.MatchString(file.Content) {
				finding := MalwareFinding{
					Type:        malwareType,
					File:        file.Path,
					Signature:   signature.String(),
					Confidence:  0.8, // Basic confidence score
					Description: vs.getMalwareDescription(malwareType),
				}
				malware = append(malware, finding)
			}
		}
	}
	
	return malware
}

// scanCompliance checks for compliance violations.
func (vs *VulnerabilityScanner) scanCompliance(layer LayerInfo) []ComplianceFinding {
	var compliance []ComplianceFinding
	
	// CIS Docker Benchmark checks
	compliance = append(compliance, vs.checkCISCompliance(layer)...)
	
	// NIST compliance checks
	compliance = append(compliance, vs.checkNISTCompliance(layer)...)
	
	// Custom compliance rules
	compliance = append(compliance, vs.checkCustomCompliance(layer)...)
	
	return compliance
}

// Helper types and methods

type LayerInfo struct {
	ID       string
	Size     int64
	Command  string
	Packages []*extractor.Package
	Files    []FileInfo
}

type FileInfo struct {
	Path    string
	Content string
	Mode    string
	Size    int64
}

type ContainerScanResult struct {
	ScanID    string          `json:"scan_id"`
	Timestamp time.Time       `json:"timestamp"`
	Layers    []LayerAnalysis `json:"layers"`
	Summary   ScanSummary     `json:"summary"`
}

type ScanSummary struct {
	TotalVulnerabilities int `json:"total_vulnerabilities"`
	CriticalCount        int `json:"critical_count"`
	HighCount            int `json:"high_count"`
	MediumCount          int `json:"medium_count"`
	LowCount             int `json:"low_count"`
	SecretsFound         int `json:"secrets_found"`
	MalwareFound         int `json:"malware_found"`
	ComplianceViolations int `json:"compliance_violations"`
}

// Helper methods implementation

func (vs *VulnerabilityScanner) initializeBuiltinRules() {
	// Initialize built-in security rules
	log.Debugf("Initialized %d built-in security rules", len(vs.config.CustomRules))
}

func (vs *VulnerabilityScanner) loadVulnerabilityDatabase() {
	// Load vulnerability database from various sources
	log.Debugf("Loaded vulnerability database with %d entries", len(vs.vulnerabilityDB))
}

func (vs *VulnerabilityScanner) packageMatchesVulnerability(pkg *extractor.Package, vuln *VulnerabilityInfo) bool {
	for _, affected := range vuln.Affected {
		if strings.Contains(affected, pkg.Name) {
			return true
		}
	}
	return false
}

func (vs *VulnerabilityScanner) getVulnerabilityRemediation(vulnID string) string {
	return fmt.Sprintf("Update the affected package to a version that fixes %s", vulnID)
}

func (vs *VulnerabilityScanner) shouldSkipSecretScan(path string) bool {
	skipPatterns := []string{".git/", "node_modules/", "vendor/", ".jpg", ".png", ".pdf"}
	for _, pattern := range skipPatterns {
		if strings.Contains(path, pattern) {
			return true
		}
	}
	return false
}

func (vs *VulnerabilityScanner) shouldSkipMalwareScan(path string) bool {
	return vs.shouldSkipSecretScan(path)
}

func (vs *VulnerabilityScanner) calculateSecretConfidence(secretType, match string) float64 {
	// Basic confidence calculation
	switch secretType {
	case "aws_access_key", "github_token":
		return 0.95
	case "private_key":
		return 0.90
	case "jwt_token":
		return 0.85
	default:
		return 0.75
	}
}

func (vs *VulnerabilityScanner) maskSecret(secret string) string {
	if len(secret) <= 8 {
		return "***"
	}
	return secret[:4] + "***" + secret[len(secret)-4:]
}

func (vs *VulnerabilityScanner) getMalwareDescription(malwareType string) string {
	descriptions := map[string]string{
		"suspicious_shell":     "Suspicious shell command execution pattern detected",
		"reverse_shell":        "Potential reverse shell command detected",
		"crypto_miner":         "Cryptocurrency mining software detected",
		"backdoor_pattern":     "Potential backdoor or malicious software detected",
		"suspicious_download":  "Suspicious file download and execution pattern",
		"data_exfiltration":    "Potential data exfiltration pattern detected",
	}
	
	if desc, ok := descriptions[malwareType]; ok {
		return desc
	}
	return "Unknown malware pattern detected"
}

func (vs *VulnerabilityScanner) checkCISCompliance(layer LayerInfo) []ComplianceFinding {
	var findings []ComplianceFinding
	
	// CIS Docker Benchmark 4.1 - Ensure a user for the container has been created
	if strings.Contains(layer.Command, "USER root") || !strings.Contains(layer.Command, "USER") {
		findings = append(findings, ComplianceFinding{
			Standard:    "CIS Docker Benchmark",
			Rule:        "4.1",
			Severity:    "medium",
			Description: "Container should not run as root user",
			Remediation: "Add USER directive to specify non-root user",
		})
	}
	
	return findings
}

func (vs *VulnerabilityScanner) checkNISTCompliance(layer LayerInfo) []ComplianceFinding {
	var findings []ComplianceFinding
	
	// NIST compliance checks would go here
	// This is a placeholder for demonstration
	
	return findings
}

func (vs *VulnerabilityScanner) checkCustomCompliance(layer LayerInfo) []ComplianceFinding {
	var findings []ComplianceFinding
	
	// Custom compliance rules would go here
	
	return findings
}

func (vs *VulnerabilityScanner) aggregateFindings(layers []LayerAnalysis) ScanSummary {
	summary := ScanSummary{}
	
	for _, layer := range layers {
		for _, finding := range layer.Findings {
			summary.TotalVulnerabilities++
			switch strings.ToLower(finding.Severity) {
			case "critical":
				summary.CriticalCount++
			case "high":
				summary.HighCount++
			case "medium":
				summary.MediumCount++
			case "low":
				summary.LowCount++
			}
		}
		summary.SecretsFound += len(layer.Secrets)
		summary.MalwareFound += len(layer.Malware)
		summary.ComplianceViolations += len(layer.Compliance)
	}
	
	return summary
}

func generateScanID() string {
	hash := sha256.Sum256([]byte(fmt.Sprintf("%d", time.Now().UnixNano())))
	return fmt.Sprintf("scan_%x", hash[:8])
}